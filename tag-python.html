<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://whatacold.github.io/rss.xml"
      title="RSS feed for https://whatacold.github.io/"/>
<title>whatacold's blog site</title>
<meta name="author" content="Guangwang Huang">
<meta name="referrer" content="no-referrer">
<link href= "static/style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="header">
<div class="sitelinks">
    <a href="https://github.com/whatacold">GitHub</a> | <a href="https://stackoverflow.com/users/910978/whatacold">Stack Overflow</a> | <a href="mailto:whatacold@gmail.com">Email</a> | <a href="/rss.xml">RSS</a>
</div></div>
<div id="content">
<h1 class="title">Posts tagged "Python":</h1>
<div class="post-date">06 Jul 2019</div><h1 class="post-title"><a href="2019-07-06-render-erd-on-the-web.html">Preview erd on the web</a></h1>
<p>
If you ever wonder how to plot ER diagrams in plain text, you may have already heard of <a href="https://github.com/BurntSushi/erd">erd</a>.
It's a cool command line program written by Andrew Gallant in Haskell, to "compile" plain text files into nicely looking images,
leveraging the power of GraphViz.
</p>

<p>
I've used erd for some time, it's cool and the syntax is quite simple.
It's also quite simple to install it on Linux, just install GraphViz and erd itself,
by following the instructions in the README page.
</p>

<p>
But there are times that there isn't an erd environment at hand:
</p>
<ul class="org-ul">
<li>erd is hard to install, or we don't have the permission to install it.</li>
<li>I shared the plain text file with my teammates, but they didn't know how to convert it to an image.</li>
</ul>

<p>
So I think maybe it's useful to have a web application that folks can try it out online,
here it is: <a href="https://serene-forest-18642.herokuapp.com/">erd-repl</a> , a simple Flask application hosted on Heroku.
Although the name REPL, it's far from being a REPL, I think that a REPL helps ease the learning process, be it Emacs REPL, or Python REPL, as it gives you feedback as you type.
</p>

<p>
It's so simple that there isn't any user authentication mechanism, and here are some caveats:
</p>
<ul class="org-ul">
<li>the "source code" of plain text is simply stored in the browser cookie, together with your id.</li>
<li>no edit features, you need to edit it somewhere, e.g. Emacs, and then copied to erd-repl if it's complex, to prevent data loss.</li>
<li>only one image is stored per one user.</li>
<li>imaged will be cleared if being not touched for a few days</li>
</ul>

<p>
After hosting it on Heroku, I found that there is an <a href="https://github.com/BurntSushi/erd/issues/1">issue</a> discussing hosting a web service of erd on GitHub,
take a look too if you're interested.
</p>

<p>
P.S. I know the UI is ugly. I have basic knowledge of CSS, but I just don't have the sense to layout elements properly, what materials/practices would you recommend improving my front end skill at this stage? or any tips on the UI itself?</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-python.html">Python</a> <a href="tag-tools.html">Tools</a> </div>
<div class="post-date">22 Dec 2018</div><h1 class="post-title"><a href="2018-12-22-c-cpp-devel-with-lsp-in-emacs.html">在 Emacs 中使用 LSP 开发 C/C++ 工程</a></h1>
<p>
写代码的时候，如果能够基于当前的上下文提示补全，不仅能提高写代码的效率，还能提升体验，有种行云流水的感觉。
Emacs 中之前我用 gtags 等静态的工具来辅助写代码，最大的问题是无法根据上下文补全，体验不好。
有了 LSP 协议之后， Emacs 中现在也能实现这个功能了，体验相当不错。
前段时间折腾了一下，在此作个小结。
</p>

<p>
目前 Emacs 上有两个客户端实现： <a href="https://github.com/joaotavora/eglot">eglot</a> 和 <a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> ，由于 eglot 相对比较简洁，只需要很少的配置，因此我就选它了（暂时还没试过 lsp-mode ，等有需要时再看）。
</p>

<p>
对于服务端，目前有三个选择 clangd,  <a href="https://github.com/cquery-project/cquery">cquery</a> 和 <a href="https://github.com/MaskRay/ccls">ccls</a> ， ccls 是在 cquery 的基础之上 fork 改进的。
clangd 安装最简单，但功能据说比较弱，我没有试过；一开始我在自己电脑上编译了 ccls ，再把二进制文件拷贝到公司机器，
但是补全始终有问题（怀疑必须在使用的机器上编译，直接拷贝行不通），没有找到具体的原因；
后来在公司机器上直接编译了 cquery ，可以补全，就没有再折腾 ccls 了。
</p>

<p>
选定了客户端和服务端之后，接下来就是对具体工程的配置了， cquery 和 ccls 都要求工程根目录有 compilation database 或者 <code>.cquery</code> / <code>.ccls</code> 文件。
由于我们的工程都是用 GNU Make 进行构建的，没法使用 <code>cmake</code> 直接生成 compilation database 。
其他方案比如 <a href="https://github.com/rizsotto/Bear">Bear</a> ，由于我们的工具链太老，没有 <code>cmake</code> 无法编译 <code>Bear</code> ，因此也派不上用场。
至此由于无法生成服务器的配置文件，看来似乎与 LSP 无缘了。
</p>

<p>
后来有一天，突然想到可以直接自己解析 <code>make</code> 的输出（就用 Elisp ），解析 <code>Entering directory</code> , <code>Leaving directory</code> 以及 <code>g++</code> 编译的相关行，
提取生成为 <code>compile_commands.json</code> ，这样就无须再依赖其他软件。
但是此方法有一个缺点，在新增文件的时候，得人工在 json 文件中增加一条记录，比较麻烦，不易维护。
</p>

<p>
其实此种情况下直接用 <code>.cquery</code> 文件最好，无需指定特定的源码文件，
只需要配置编译选项以及头文件目录，因此新增文件时不需要修改。
举一个 cquery wiki 中的 <a href="https://github.com/cquery-project/cquery/wiki/.cquery">例子</a> ：
</p>

<pre class="example">
# it will expend to clang/clang++ according to the extension name
%clang

# C specific options
%c -std=gnu11

# C++ specific options
%cpp -std=gnu++14
-pthread

# Includes
-I/work/cquery/third_party
-I/work/cquery/another_third_party
# -I space_is_not_allowed
</pre>


<p>
到此似乎万事俱备，可以愉快地写代码了，最终却发现还有一个问题：由于历史原因，我们的工程源码都是使用 GBK 编码的，
但是 LSP 只支持 UTF-8 ，导致由于编码问题无法显示类、函数注释的问题，当时还在 eglot 提了一个 <a href="https://github.com/joaotavora/eglot/issues/135">issue</a> （其实不是 eglot 的问题）。
</p>

<p>
为了解决这个问题想过几种方法：
</p>
<ol class="org-ol">
<li>cquery 中在输出之前，把内容转为 UTF-8 编码（利用 <code>iconv</code> 库）</li>
<li><code>eglot</code> 在解析服务端返回的数据时，根据指定的编码进行 decode</li>
</ol>

<p>
第一种方法适用面太窄，因为 LSP 的实现还不是非常成熟，有时需要切换到 <code>ccls</code> 来体验，
这就意味着得在 <code>ccls</code> 中也用 <code>iconv</code> 再转一道，太麻烦，不符合 <code>DRY</code> 的原则。
</p>

<p>
第二种方法，需要在 <code>eglot.el</code> 和其依赖的低层通信库 <code>jsonrpc.el</code> 中同时服务端传回数据的编码方式。
当时也实现了，后来觉得不是很直接、优雅，就没再继续用了。另外，如果有一天改用 lsp-mode ，
那又需要在 lsp-mode 中做一遍类似的修改，同样也不符合 <code>DRY</code> 原则。
</p>

<p>
最后使用了适配器的 <a href="https://github.com/whatacold/lsa">方案</a> ，使用 Python 3 实现，既不动客户端也不动服务端，在中间加一层，用于转换服务端的编码。
这样就是一个比较通用的方案了，能适配所有的客户端和服务端。
</p>

<p>
在 eglot 中根据项目的编码情况（通过 <code>.dir-locals.el</code> 区分）决定是否使用此适配器：
</p>

<div class="org-src-container">
<pre class="src src-elisp">
(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">ccls-init-args</span> nil
  <span style="color: #16a085;">"Init args for ccls, e.g. '(:clang (:extraArgs (\"-std=c++03\")))"</span>)

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">eglot-ls-output-encoding</span> <span style="color: #16a085;">"utf-8"</span>
  <span style="color: #16a085;">"The LS's output encoding"</span>)

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">eglot-cpp-ls</span> <span style="color: #16a085;">"cquery"</span>
  <span style="color: #16a085;">"The language server for C/C++."</span>)

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/eglot-ccls-contact</span> (interactive-p)
  <span style="color: #16a085;">"A contact function to assemble args for ccls.</span>
<span style="color: #16a085;">Argument INTERACTIVE-P indicates where it's called interactively."</span>
  (<span style="color: #2c3e50; font-style: italic;">let</span> ((json-object-type 'plist)
        (json-array-type 'list)
        result)
    (<span style="color: #2c3e50; font-style: italic;">cond</span> ((equal <span style="color: #16a085;">"ccls"</span> eglot-cpp-ls)
           (<span style="color: #2c3e50; font-style: italic;">push</span> (format <span style="color: #16a085;">"-log-file=/tmp/ccls-%s.log"</span>
                         (file-name-base
                          (directory-file-name
                           (car
                            (project-roots
                             (project-current))))))
                 result)
           (<span style="color: #2c3e50; font-style: italic;">when</span> ccls-init-args
             (<span style="color: #2c3e50; font-style: italic;">push</span> (format <span style="color: #16a085;">"-init=%s"</span> (json-encode
                                       ccls-init-args))
                   result))
           (<span style="color: #2c3e50; font-style: italic;">push</span> <span style="color: #16a085;">"ccls"</span> result))
          ((equal <span style="color: #16a085;">"cquery"</span> eglot-cpp-ls)
           (<span style="color: #2c3e50; font-style: italic;">setq</span> result (list <span style="color: #16a085;">"cquery"</span> <span style="color: #16a085;">"--log-all-to-stderr"</span>)))
          (t <span style="color: #95a5a6; font-style: italic;">; </span><span style="color: #95a5a6; font-style: italic;">e.g. clangd</span>
           (<span style="color: #2c3e50; font-style: italic;">push</span> eglot-cpp-ls result)))
    <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">apply the adapter if necessary</span>
    (<span style="color: #2c3e50; font-style: italic;">unless</span> (equal eglot-ls-output-encoding <span style="color: #16a085;">"utf-8"</span>)
      (<span style="color: #2c3e50; font-style: italic;">dolist</span> (item (reverse (list <span style="color: #16a085;">"lsa.py"</span>
                                   (concat <span style="color: #16a085;">"--original-response-encoding="</span>
                                           eglot-ls-output-encoding)
                                   <span style="color: #16a085;">"--log-level=DEBUG"</span>
                                   <span style="color: #16a085;">"--"</span>)))
        (<span style="color: #2c3e50; font-style: italic;">push</span> item result)))
    <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">cquery should apply the specific class in eglot</span>
    (<span style="color: #2c3e50; font-style: italic;">when</span> (equal <span style="color: #16a085;">"cquery"</span> eglot-cpp-ls)
      (<span style="color: #2c3e50; font-style: italic;">push</span> 'eglot-cquery result))
    result))

(eval-after-load 'eglot
  '(<span style="color: #2c3e50; font-style: italic;">progn</span>
     (add-to-list 'eglot-server-programs
                  (cons '(c-mode c++-mode foo-mode) #'whatacold/eglot-ccls-contact))))
</pre>
</div>

<p>
至此 LSP 基本可用了。</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> <a href="tag-c++.html">C++</a> <a href="tag-python.html">Python</a> </div><div id="archive">
<a href="archive.html">Other posts</a>
</div>
</div>
</body>
</html>

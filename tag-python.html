<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://whatacold.github.io/rss.xml"
      title="RSS feed for https://whatacold.github.io/"/>
<title>whatacold's blog site</title>
<meta name="author" content="Guangwang Huang">
<meta name="referrer" content="no-referrer">
<link href= "static/style.css" rel="stylesheet" type="text/css" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-74588785-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-74588785-1');
</script>
</head>
<body>
<div id="preamble" class="status"><div class="header">
<div class="sitelinks">
    <a href="https://github.com/whatacold">GitHub</a> | <a href="https://stackoverflow.com/users/910978/whatacold">Stack Overflow</a> | <a href="mailto:whatacold@gmail.com">Email</a> | <a href="/rss.xml">RSS</a>
</div></div>
<div id="content">
<h1 class="title">Posts tagged "Python":</h1>
<div class="post-date">01 Oct 2019</div><h1 class="post-title"><a href="2019-10-01-reboot-tianyi-router-using-python-requests.html">用 Python Requests “一键”重启天翼路由器</a></h1>
<p>
不知道什么原因，我的网络有时候会很慢，而通过重启天翼网关路由器（版本 V1.0 ）大概率能够恢复。这样重启的次数多了之后会觉得有点繁琐，本着偷懒的原则，就想写一个脚本来自动重启，那样的话会“方便”很多。
</p>

<p>
经过一番折腾，查看其控制台的网页代码，最后终于搞定。通过使用 <a href="https://requests.kennethreitz.org/en/master/">Python Requests</a> 库串联登录及重启两个步骤，达到“一键”自动重启路由器的目的。 Python 脚本如下：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #95a5a6; font-style: italic;">#</span><span style="color: #95a5a6; font-style: italic;">!/usr/bin/env python3</span>
<span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">-*- coding: utf-8 -*-</span>

<span style="color: #2c3e50; font-style: italic;">import</span> requests
<span style="color: #2c3e50; font-style: italic;">import</span> re

<span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">&#36825;&#37324;&#30340;&#37197;&#32622;&#65292;&#35831;&#25353;&#38656;&#20462;&#25913;&#12290;</span>
<span style="color: #3498db;">DEVICE_IP</span>=<span style="color: #16a085;">"192.168.1.1"</span>
<span style="color: #3498db;">USERNAME</span>=<span style="color: #16a085;">'admin'</span>
<span style="color: #3498db;">PASSWORD</span>=<span style="color: #16a085;">'foobar'</span>

<span style="color: #2c3e50; font-style: italic;">def</span> <span style="color: #9b59b6;">reboot</span>():
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #16a085;">'''Reboot the Tianyi Gateway automatically'''</span>
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">s</span> = requests.Session()
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">login_data</span> = <span style="color: #16a085;">"username={}&amp;password={}"</span>.<span style="color: #2c3e50;">format</span>(USERNAME, PASSWORD)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">response</span> = s.post(<span style="color: #16a085;">"http://{}/login.cgi"</span>.<span style="color: #2c3e50;">format</span>(DEVICE_IP), login_data)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">response_html</span> = response.text
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">matches</span> = re.findall(<span style="color: #16a085;">'var mysessionid=([0-9]+);'</span>, response_html)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">if</span> 1 != <span style="color: #2c3e50;">len</span>(matches):
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">raise</span> <span style="color: #16a085;">"No session id matched!"</span>

<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">session_id</span> = matches[0]
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">session_id = 1111 # It doesn't care what it REALLY is</span>
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">response</span> = s.post(<span style="color: #16a085;">"http://{}/restartGateWay.json?sessionKey={}"</span>.<span style="color: #2c3e50;">format</span>(DEVICE_IP,
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>  session_id),
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span> <span style="color: #16a085;">"action=restartGateWay&amp;actionid=8"</span>)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">text</span> = response.text <span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">{ "status": "success", "actionid": "8" }</span>
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">return_object</span> = response.json()
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">if</span> <span style="color: #16a085;">"success"</span> == return_object[<span style="color: #16a085;">"status"</span>]:
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">print</span>(<span style="color: #16a085;">"Device rebooted successfully, wait a minute!"</span>)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">else</span>:
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">print</span>(<span style="color: #16a085;">"Failed to reboot the device, return json: {}"</span>.<span style="color: #2c3e50;">format</span>(text))

<span style="color: #2c3e50; font-style: italic;">if</span> <span style="color: #2c3e50;">__name__</span> == <span style="color: #16a085;">'__main__'</span>:
<span style="background-color: #ecf0f1;"> </span>   reboot()
</pre>
</div>

<p>
此脚本依赖 Python Requests 库，可以通过 <code>pip</code> 来安装；我使用 Python3 ，不过 Python2 应该也不会有太大问题。
把上述脚本保存到文件中，比如 <code>~/bin/reboot-tianyi-gateway</code> ，并且增加可执行权限（ <code>chmod +x ~/bin/reboot-tianyi-gateway</code> ），在需要的时候在终端中执行 <code>~/bin/reboot-tianyi-gateway</code> 即可。 :)
</p>

<p>
另外，正如注释中提到的，其实 <code>/restartGateWay.json</code> 这个是一个裸接口，并没有校验 <code>sessionKey</code> 的有效性；甚至登录接口在用户登录之后也不会设置 cookie ，所有的业务接口都是可以直接调用的，也就是说，登录界面只是一个摆设。 :(
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-python.html">Python</a> <a href="tag-zhongwen.html">zhongwen</a> </div>
<div class="post-date">29 Sep 2019</div><h1 class="post-title"><a href="2019-09-29-how-to-run-the-bleeding-edge-code-of-qtile-within-virtualenv.html">How to run the bleeding-edge code of Qtile within a virtualenv</a></h1>
<p>
For having been using GNOME for quite a long time, I was considering trying some tiling window managers to see what it's like a few weeks ago. Along the way, I found a nice window manager written in Python: <a href="http://www.qtile.org">Qtile</a>, what interests me most is that it's a <b>hackable</b> window manager, which makes it flexible to extend or change its behaviors.
</p>

<p>
Well, switching to use a tiling window manager is far simpler than I thought. There are two ways to have it:
</p>
<ol class="org-ol">
<li>Installing it via the system's package manager, e.g. <code>dnf</code> for Fedora</li>
<li>Installing it from the source code repo.</li>
</ol>

<p>
If you just want to give it a try, you can just install it via a package manager, logout the current X session, and re-login with Qtile as your window manager (there are options when you log in), and you're done. It's that simple.
</p>

<p>
As Qtile is still under development, I would like to run the bleeding-edge source code to catch up with Qtile.
</p>

<p>
As in the <a href="http://docs.qtile.org/en/latest/manual/install/index.html#qtile">docs</a> , it's quite straight-forward to install it.
</p>

<div class="org-src-container">
<pre class="src src-shell">git clone git://github.com/qtile/qtile.git
<span style="color: #2c3e50;">cd</span> qtile
pip3 install .
</pre>
</div>

<p>
But it will pollute the environment, so I'd rather contain it within a virtualenv, here are the steps how to run it within a dedicated virtualenv for user <code>foo</code> on Fedora.
</p>

<ol class="org-ol">
<li><p>
Clone the repo
</p>

<div class="org-src-container">
<pre class="src src-shell">mkdir -p ~/local/
git clone https://github.com/qtile/qtile.git
</pre>
</div></li>

<li><p>
Create a new virtualenv, and install dependencies there
</p>

<div class="org-src-container">
<pre class="src src-shell">python3 -m venv ~/local/qtile/qtile-env/
<span style="color: #2c3e50;">source</span> ~/local/qtile/qtile-env/bin/activate

<span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">Install dependencies</span>
pip install xcffib
pip install --no-cache-dir cairocffi
</pre>
</div></li>

<li><p>
Make a glue shell script to use the virtualenv
</p>

<div class="org-src-container">
<pre class="src src-shell">cat &gt; /home/foo/local/qtile/qtile-venv-entry &lt;&lt;EOF
<span style="color: #16a085;">#!/bin/bash</span>

<span style="color: #16a085;"># This glue shell is only needed when you want to</span>
<span style="color: #16a085;"># run Qtile within a virtualenv</span>

<span style="color: #16a085;">source ~/local/qtile/qtile-env/bin/activate</span>
<span style="color: #16a085;">python ~/local/qtile/bin/qtile $*</span>
<span style="color: #16a085;">EOF</span>
</pre>
</div>

<p>
Also, make sure to make it executable, that is, <code>chmod +x /home/foo/local/qtile/qtile-venv-entry</code>
</p></li>

<li><p>
Make a entry desktop file for the display manager
</p>

<div class="org-src-container">
<pre class="src src-shell">cat &gt; /usr/share/xsessions/qtile-venv.desktop &lt;&lt;EOF
<span style="color: #16a085;">[Desktop Entry]</span>
<span style="color: #16a085;">Name=Qtile(venv)</span>
<span style="color: #16a085;">Comment=Qtile Session Within Venv</span>
<span style="color: #16a085;">Exec=/home/foo/local/qtile/qtile-venv-entry</span>
<span style="color: #16a085;">Type=Application</span>
<span style="color: #16a085;">Keywords=wm;tiling</span>
<span style="color: #16a085;">EOF</span>
</pre>
</div>

<p>
Pay attention to the <code>Exec</code> directive, it points to the glue script.
</p></li>

<li>Log out or reboot your system, then select “Qtile(venv)” as your window manager by clicking the setting icon when logging in.</li>
</ol>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-python.html">Python</a> <a href="tag-tiling-wm.html">tiling-wm</a> </div>
<div class="post-date">06 Jul 2019</div><h1 class="post-title"><a href="2019-07-06-render-erd-on-the-web.html">Preview erd on the web</a></h1>
<p>
If you ever wonder how to plot ER diagrams in plain text, you may have already heard of <a href="https://github.com/BurntSushi/erd">erd</a>.
It's a cool command line program written by Andrew Gallant in Haskell, to "compile" plain text files into nicely looking images,
leveraging the power of GraphViz.
</p>

<p>
I've used erd for some time, it's cool and the syntax is quite simple.
It's also quite simple to install it on Linux, just install GraphViz and erd itself,
by following the instructions in the README page.
</p>

<p>
But there are times that there isn't an erd environment at hand:
</p>
<ul class="org-ul">
<li>erd is hard to install, or we don't have the permission to install it.</li>
<li>I shared the plain text file with my teammates, but they didn't know how to convert it to an image.</li>
</ul>

<p>
So I think maybe it's useful to have a web application that folks can try it out online,
here it is: <a href="https://serene-forest-18642.herokuapp.com/">erd-repl</a> , a simple Flask application hosted on Heroku.
Although the name REPL, it's far from being a REPL, I think that a REPL helps ease the learning process, be it Emacs REPL, or Python REPL, as it gives you feedback as you type.
</p>

<p>
It's so simple that there isn't any user authentication mechanism, and here are some caveats:
</p>
<ul class="org-ul">
<li>the "source code" of plain text is simply stored in the browser cookie, together with your id.</li>
<li>no edit features, you need to edit it somewhere, e.g. Emacs, and then copied to erd-repl if it's complex, to prevent data loss.</li>
<li>only one image is stored per one user.</li>
<li>imaged will be cleared if being not touched for a few days</li>
</ul>

<p>
After hosting it on Heroku, I found that there is an <a href="https://github.com/BurntSushi/erd/issues/1">issue</a> discussing hosting a web service of erd on GitHub,
take a look too if you're interested.
</p>

<p>
P.S. I know the UI is ugly. I have basic knowledge of CSS, but I just don't have the sense to layout elements properly, what materials/practices would you recommend improving my front end skill at this stage? or any tips on the UI itself?</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-python.html">Python</a> <a href="tag-tools.html">Tools</a> </div>
<div class="post-date">22 Dec 2018</div><h1 class="post-title"><a href="2018-12-22-c-cpp-devel-with-lsp-in-emacs.html">在 Emacs 中使用 LSP 开发 C/C++ 工程</a></h1>
<p>
写代码的时候，如果能够基于当前的上下文提示补全，不仅能提高写代码的效率，还能提升体验，有种行云流水的感觉。
Emacs 中之前我用 gtags 等静态的工具来辅助写代码，最大的问题是无法根据上下文补全，体验不好。
有了 LSP 协议之后， Emacs 中现在也能实现这个功能了，体验相当不错。
前段时间折腾了一下，在此作个小结。
</p>

<p>
目前 Emacs 上有两个客户端实现： <a href="https://github.com/joaotavora/eglot">eglot</a> 和 <a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> ，由于 eglot 相对比较简洁，只需要很少的配置，因此我就选它了（暂时还没试过 lsp-mode ，等有需要时再看）。
</p>

<p>
对于服务端，目前有三个选择 clangd,  <a href="https://github.com/cquery-project/cquery">cquery</a> 和 <a href="https://github.com/MaskRay/ccls">ccls</a> ， ccls 是在 cquery 的基础之上 fork 改进的。
clangd 安装最简单，但功能据说比较弱，我没有试过；一开始我在自己电脑上编译了 ccls ，再把二进制文件拷贝到公司机器，
但是补全始终有问题（怀疑必须在使用的机器上编译，直接拷贝行不通），没有找到具体的原因；
后来在公司机器上直接编译了 cquery ，可以补全，就没有再折腾 ccls 了。
</p>

<p>
选定了客户端和服务端之后，接下来就是对具体工程的配置了， cquery 和 ccls 都要求工程根目录有 compilation database 或者 <code>.cquery</code> / <code>.ccls</code> 文件。
由于我们的工程都是用 GNU Make 进行构建的，没法使用 <code>cmake</code> 直接生成 compilation database 。
其他方案比如 <a href="https://github.com/rizsotto/Bear">Bear</a> ，由于我们的工具链太老，没有 <code>cmake</code> 无法编译 <code>Bear</code> ，因此也派不上用场。
至此由于无法生成服务器的配置文件，看来似乎与 LSP 无缘了。
</p>

<p>
后来有一天，突然想到可以直接自己解析 <code>make</code> 的输出（就用 Elisp ），解析 <code>Entering directory</code> , <code>Leaving directory</code> 以及 <code>g++</code> 编译的相关行，
提取生成为 <code>compile_commands.json</code> ，这样就无须再依赖其他软件。
但是此方法有一个缺点，在新增文件的时候，得人工在 json 文件中增加一条记录，比较麻烦，不易维护。
</p>

<p>
其实此种情况下直接用 <code>.cquery</code> 文件最好，无需指定特定的源码文件，
只需要配置编译选项以及头文件目录，因此新增文件时不需要修改。
举一个 cquery wiki 中的 <a href="https://github.com/cquery-project/cquery/wiki/.cquery">例子</a> ：
</p>

<pre class="example">
# it will expend to clang/clang++ according to the extension name
%clang

# C specific options
%c -std=gnu11

# C++ specific options
%cpp -std=gnu++14
-pthread

# Includes
-I/work/cquery/third_party
-I/work/cquery/another_third_party
# -I space_is_not_allowed
</pre>


<p>
到此似乎万事俱备，可以愉快地写代码了，最终却发现还有一个问题：由于历史原因，我们的工程源码都是使用 GBK 编码的，
但是 LSP 只支持 UTF-8 ，导致由于编码问题无法显示类、函数注释的问题，当时还在 eglot 提了一个 <a href="https://github.com/joaotavora/eglot/issues/135">issue</a> （其实不是 eglot 的问题）。
</p>

<p>
为了解决这个问题想过几种方法：
</p>
<ol class="org-ol">
<li>cquery 中在输出之前，把内容转为 UTF-8 编码（利用 <code>iconv</code> 库）</li>
<li><code>eglot</code> 在解析服务端返回的数据时，根据指定的编码进行 decode</li>
</ol>

<p>
第一种方法适用面太窄，因为 LSP 的实现还不是非常成熟，有时需要切换到 <code>ccls</code> 来体验，
这就意味着得在 <code>ccls</code> 中也用 <code>iconv</code> 再转一道，太麻烦，不符合 <code>DRY</code> 的原则。
</p>

<p>
第二种方法，需要在 <code>eglot.el</code> 和其依赖的低层通信库 <code>jsonrpc.el</code> 中同时服务端传回数据的编码方式。
当时也实现了，后来觉得不是很直接、优雅，就没再继续用了。另外，如果有一天改用 lsp-mode ，
那又需要在 lsp-mode 中做一遍类似的修改，同样也不符合 <code>DRY</code> 原则。
</p>

<p>
最后使用了适配器的 <a href="https://github.com/whatacold/lsa">方案</a> ，使用 Python 3 实现，既不动客户端也不动服务端，在中间加一层，用于转换服务端的编码。
这样就是一个比较通用的方案了，能适配所有的客户端和服务端。
</p>

<p>
在 eglot 中根据项目的编码情况（通过 <code>.dir-locals.el</code> 区分）决定是否使用此适配器：
</p>

<div class="org-src-container">
<pre class="src src-elisp">
(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">ccls-init-args</span> nil
  <span style="color: #16a085;">"Init args for ccls, e.g. '(:clang (:extraArgs (\"-std=c++03\")))"</span>)

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">eglot-ls-output-encoding</span> <span style="color: #16a085;">"utf-8"</span>
  <span style="color: #16a085;">"The LS's output encoding"</span>)

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">eglot-cpp-ls</span> <span style="color: #16a085;">"cquery"</span>
  <span style="color: #16a085;">"The language server for C/C++."</span>)

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/eglot-ccls-contact</span> (interactive-p)
  <span style="color: #16a085;">"A contact function to assemble args for ccls.</span>
<span style="color: #16a085;">Argument INTERACTIVE-P indicates where it's called interactively."</span>
  (<span style="color: #2c3e50; font-style: italic;">let</span> ((json-object-type 'plist)
        (json-array-type 'list)
        result)
    (<span style="color: #2c3e50; font-style: italic;">cond</span> ((equal <span style="color: #16a085;">"ccls"</span> eglot-cpp-ls)
           (<span style="color: #2c3e50; font-style: italic;">push</span> (format <span style="color: #16a085;">"-log-file=/tmp/ccls-%s.log"</span>
                         (file-name-base
                          (directory-file-name
                           (car
                            (project-roots
                             (project-current))))))
                 result)
           (<span style="color: #2c3e50; font-style: italic;">when</span> ccls-init-args
             (<span style="color: #2c3e50; font-style: italic;">push</span> (format <span style="color: #16a085;">"-init=%s"</span> (json-encode
                                       ccls-init-args))
                   result))
           (<span style="color: #2c3e50; font-style: italic;">push</span> <span style="color: #16a085;">"ccls"</span> result))
          ((equal <span style="color: #16a085;">"cquery"</span> eglot-cpp-ls)
           (<span style="color: #2c3e50; font-style: italic;">setq</span> result (list <span style="color: #16a085;">"cquery"</span> <span style="color: #16a085;">"--log-all-to-stderr"</span>)))
          (t <span style="color: #95a5a6; font-style: italic;">; </span><span style="color: #95a5a6; font-style: italic;">e.g. clangd</span>
           (<span style="color: #2c3e50; font-style: italic;">push</span> eglot-cpp-ls result)))
    <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">apply the adapter if necessary</span>
    (<span style="color: #2c3e50; font-style: italic;">unless</span> (equal eglot-ls-output-encoding <span style="color: #16a085;">"utf-8"</span>)
      (<span style="color: #2c3e50; font-style: italic;">dolist</span> (item (reverse (list <span style="color: #16a085;">"lsa.py"</span>
                                   (concat <span style="color: #16a085;">"--original-response-encoding="</span>
                                           eglot-ls-output-encoding)
                                   <span style="color: #16a085;">"--log-level=DEBUG"</span>
                                   <span style="color: #16a085;">"--"</span>)))
        (<span style="color: #2c3e50; font-style: italic;">push</span> item result)))
    <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">cquery should apply the specific class in eglot</span>
    (<span style="color: #2c3e50; font-style: italic;">when</span> (equal <span style="color: #16a085;">"cquery"</span> eglot-cpp-ls)
      (<span style="color: #2c3e50; font-style: italic;">push</span> 'eglot-cquery result))
    result))

(eval-after-load 'eglot
  '(<span style="color: #2c3e50; font-style: italic;">progn</span>
     (add-to-list 'eglot-server-programs
                  (cons '(c-mode c++-mode foo-mode) #'whatacold/eglot-ccls-contact))))
</pre>
</div>

<p>
至此 LSP 基本可用了。</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> <a href="tag-c++.html">C++</a> <a href="tag-python.html">Python</a> <a href="tag-zhongwen.html">zhongwen</a> </div><div id="archive">
<a href="archive.html">Other posts</a>
</div>
</div>
</body>
</html>

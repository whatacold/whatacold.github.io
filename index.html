<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://whatacold.github.io/rss.xml"
      title="RSS feed for https://whatacold.github.io/"/>
<title>whatacold's blog site</title>
<meta name="author" content="Guangwang Huang">
<meta name="referrer" content="no-referrer">
<link href= "static/style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="header">
<div class="sitelinks">
    <a href="https://github.com/whatacold">Github</a> | <a href="https://stackoverflow.com/users/910978/whatacold">Stack Overflow</a> | <a href="mailto:whatacold@gmail.com">Email</a> | <a href="/rss.xml">RSS</a>
</div></div>
<div id="content">

<div class="post-date">06 Jul 2019</div><h1 class="post-title"><a href="2019-07-06-render-erd-on-the-web.html">Preview erd on the web</a></h1>
<p>
If you ever wonder how to plot ER diagrams in plain text, you may have already heard of <a href="https://github.com/BurntSushi/erd">erd</a>.
It's a cool command line program written by Andrew Gallant in Haskell, to "compile" plain text files into nicely looking images,
leveraging the power of GraphViz.
</p>

<p>
I've used erd for some time, it's cool and the syntax is quite simple.
It's also quite simple to install it on Linux, just install GraphViz and erd itself,
by following the instructions in the README page.
</p>

<p>
But there are times that there isn't an erd environment at hand:
</p>
<ul class="org-ul">
<li>erd is hard to install, or we don't have the permission to install it.</li>
<li>I shared the plain text file with my teammates, but they didn't know how to convert it to an image.</li>
</ul>

<p>
So I think maybe it's useful to have a web application that folks can try it out online,
here it is: <a href="https://serene-forest-18642.herokuapp.com/">erd-repl</a> , a simple Flask application hosted on Heroku.
Although the name REPL, it's far from being a REPL, I think that a REPL helps ease the learning process, be it Emacs REPL, or Python REPL, as it gives you feedback as you type.
</p>

<p>
It's so simple that there isn't any user authentication mechanism, and here are some caveats:
</p>
<ul class="org-ul">
<li>the "source code" of plain text is simply stored in the browser cookie, together with your id.</li>
<li>no edit features, you need to edit it somewhere, e.g. Emacs, and then copied to erd-repl if it's complex, to prevent data loss.</li>
<li>only one image is stored per one user.</li>
<li>imaged will be cleared if being not touched for a few days</li>
</ul>

<p>
After hosting it on Heroku, I found that there is an <a href="https://github.com/BurntSushi/erd/issues/1">issue</a> discussing hosting a web service of erd on GitHub,
take a look too if you're interested.
</p>

<p>
P.S. I know the UI is ugly. I have basic knowledge of CSS, but I just don't have the sense to layout elements properly, what materials/practices would you recommend improving my front end skill at this stage? or any tips on the UI itself?</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-python.html">Python</a> <a href="tag-tools.html">Tools</a> </div>
<div class="post-date">10 Mar 2019</div><h1 class="post-title"><a href="2019-02-24-fine-tune-curly-brace-style-of-yasnippet-snippet-on-the-fly.html">Fine-tune curly braces style of yasnippet snippet on the fly</a></h1>
<p>
<a href="https://github.com/joaotavora/yasnippet">Yasnippet</a> is a good friend to help us type less and write more, whenever we write some text snippets repeatedly. And there is also an official repository called <a href="https://github.com/AndreaCrotti/yasnippet-snippets">yasnippet-snippets</a> that contains various snippets for many programming languages(modes), so that we can have many snippets in no time by installing it.
</p>

<p>
But there is a little problem when it comes to conform to different coding styles. Take the <code>if</code> snippet for example, normally it will generate code like this:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #2c3e50; font-style: italic;">if</span> (a) {
    do_something();
}
</pre>
</div>

<p>
This is fine for a K&amp;R style project, but will be kind of annoyed if we work on an allman style project,
because we need to fine-tune the style for every <code>if</code> clauses generated to like this:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #2c3e50; font-style: italic;">if</span> (a)
{
    do_something();
}
</pre>
</div>

<p>
How to fine-tune the coding styles according to the project requirement? Or at least curly braces styles, which is the one that matters most for me.
</p>

<p>
Maintaining two similar copies for every snippet is obviously not a good option, it's daunting and boring.
</p>

<p>
Fortunately, yasnippet provides a hook called <code>yas-after-exit-snippet-hook</code>, which I can take advantage of to adjust the curly braces style when needed. Below is a trivial hook that I come up with, it assumes that the snippets are in K&amp;R style, which is the style that yasnippet-snippet takes, and I prepend <code>{</code> with newlines and surround <code>}</code> with newlines when this behaviour is asked by setting <code>(setq whatacold/yasnippet-c-style 'allman)</code> .
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/style-braces-in-allman</span> (snippet)
  <span style="color: #16a085;">"Style the SNIPPET in allman brace style.</span>

<span style="color: #16a085;">There are roughly 3 basic brace styles:</span>
<span style="color: #16a085;">- Attached: The braces are attached to the end of the last line of the previous block. (Java).</span>
<span style="color: #16a085;">- Broken: The braces are broken from the previous block. (Allman).</span>
<span style="color: #16a085;">- Linux: The braces are attached except for the opening brace of a function, class, or namespace (K&amp;R, Linux).</span>

<span style="color: #16a085;">http://astyle.sourceforge.net/astyle.html#_Basic_Brace_Styles"</span>
  (<span style="color: #2c3e50; font-style: italic;">let</span> ((len (length snippet))
        (i 0)
        chars char new-str)
    (<span style="color: #2c3e50; font-style: italic;">while</span> (&lt; i len)
      (<span style="color: #2c3e50; font-style: italic;">setq</span> char (aref snippet i))
      (<span style="color: #2c3e50; font-style: italic;">case</span> char
        (?{
         (<span style="color: #2c3e50; font-style: italic;">push</span> ?\n chars)
         (<span style="color: #2c3e50; font-style: italic;">push</span> char chars))
        (?}
         (<span style="color: #2c3e50; font-style: italic;">push</span> ?\n chars)
         (<span style="color: #2c3e50; font-style: italic;">push</span> char chars)
         (<span style="color: #2c3e50; font-style: italic;">push</span> ?\n chars))
        (t
         (<span style="color: #2c3e50; font-style: italic;">push</span> char chars)))
      (<span style="color: #2c3e50; font-style: italic;">setq</span> i (1+ i)))
    (<span style="color: #2c3e50; font-style: italic;">setq</span> new-str (replace-regexp-in-string <span style="color: #16a085;">"[\n \t]+\n"</span>
                                            <span style="color: #16a085;">"\n"</span>
                                            (apply #'string (nreverse chars))))
    new-str))

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">whatacold/yasnippet-c-style</span> nil
  <span style="color: #16a085;">"Style of curly braces, e.g. 'allman."</span>
  <span style="color: #2c3e50;">:type</span> '(symbol))

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/yasnippet-exit-hook-c</span> ()
  (<span style="color: #2c3e50; font-style: italic;">let*</span> ((text-marker <span style="color: #16a085;">"the-yasnippet-exit-point;"</span>) <span style="color: #95a5a6; font-style: italic;">; </span><span style="color: #95a5a6; font-style: italic;">workaround. text property is more elegant.</span>
         (begin yas-snippet-beg)
         (end yas-snippet-end)
         (snippet (buffer-substring-no-properties begin end))
         new-snippet)
    (<span style="color: #2c3e50; font-style: italic;">when</span> (<span style="color: #2c3e50; font-style: italic;">and</span> (string-match <span style="color: #16a085;">"[{}]"</span> snippet)
               (eq 'allman whatacold/yasnippet-c-style))
      (insert text-marker)
      (<span style="color: #2c3e50; font-style: italic;">setq</span> end (+ yas-snippet-end (length text-marker)))

      (<span style="color: #2c3e50; font-style: italic;">setq</span> snippet (buffer-substring-no-properties begin end)) <span style="color: #95a5a6; font-style: italic;">; </span><span style="color: #95a5a6; font-style: italic;">re-fetch content</span>
      (<span style="color: #2c3e50; font-style: italic;">setq</span> new-snippet (whatacold/style-braces-in-allman snippet))
      (delete-region begin end)
      (insert new-snippet)

      (goto-char begin)
      <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">re-indent it in the context</span>
      (indent-region begin (+ end (- (length new-snippet)
                                     (length snippet))))
      (re-search-forward text-marker)
      (delete-char (- 0 (length text-marker))))))

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/yasnippet-exit-hook</span> ()
  <span style="color: #16a085;">"My yasnippet exit hook."</span>
  (<span style="color: #2c3e50; font-style: italic;">case</span> major-mode
    ((c-mode c++-mode)
     (whatacold/yasnippet-exit-hook-c))))

<span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">see https://github.com/joaotavora/yasnippet/issues/728</span>
(add-to-list 'yas-after-exit-snippet-hook #'whatacold/yasnippet-exit-hook)
</pre>
</div>

<p>
Now the coding experience is much better :)</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> </div>
<div class="post-date">17 Feb 2019</div><h1 class="post-title"><a href="2019-02-03-emacs-kmacro-characters-repeated-bug.html">记一个 Emacs Keyboard Macro 输入字符重复的 Bug</a></h1>
<p>
工作中不时地会使用 Emacs keyboard macro 来解决重复性的编辑任务，
但有时录制了再重放却出现输入的字符被重复了，导致出现非预期的结果。
一般此时为了赶进度，只好忍了，放弃 keyboard macro ，通过其他方式编辑了。
</p>

<p>
诡异的是等到有空闲的时候尝试重现却又重现不了，还一度以为是由于 keyboard macro 不支持输入 <code>M-x</code> 命令导致的，
但又没看到其他 Emacser 提到有此限制。
</p>

<p>
问题虽然偶尔才出现，但是一旦出现，工作流会被打断，很让人苦恼。
好在春节期间终于被我重现出来了，在启用 <a href="https://github.com/tumashu/pyim">pyim</a> 输入法的情况下必现，比如在录制时输入 <code>nihao</code> 得到了 <code>你好</code> ，
但是在 replay keyboard macro 的时候，得到的效果却相当于人工输入了 <code>nniihhaaoo</code> ，每个输入字符都被重复了一次，
自然就没法得到 <code>你好</code> 二字，详细的重现步骤见这个 pyim <a href="https://github.com/tumashu/pyim/issues/247">issue</a> 。
</p>

<p>
@tumashu 帮忙确认了 Emacs 自带的 quail-chinese 输入法也有此问题，建议我去 mailing list 问下看看。
最后 Emacs maintainer Eli Zaretskii 在 <a href="http://lists.gnu.org/archive/html/bug-gnu-emacs/2019-02/msg00391.html">这个 thread</a> 告知半年前已经有人在 <a href="https://debbugs.gnu.org/cgi/bugreport.cgi?bug=32108">Bug #32108</a> 中报告了，
且已经在 master 中修复了（ <a href="https://github.com/emacs-mirror/emacs/commit/03e3440dbbfea40b449a9f6f23a3630664275d11">commit 03e3440dbbfea40b449a9f6f23a3630664275d11</a> ），将会包含在 Emacs 27 发布中。
</p>

<p>
修复原理大致是在内核中增加一个标记 <code>inhibit--record-char</code> ，由输入法根据情况设置为 <code>t/nil</code> ，
当值为 <code>t</code> 时内核不会把事件记录到 <code>last-kbd-macro</code> 中（见 <code>record-char</code> 函数），
这样输入法出于实现需要重放的用户输入字符，就不会被重复记录到 keyboard macro 中。
</p>

<p>
Emacs 自带的输入法虽然已经解决了问题，但是 pyim 还没解决，接下来如果有时间再研究下如何解决（ Emacs 27 已经编译好了 :) ），
在彻底解决之前，如果在录制 keyboard macro 时不需要输入中文，可以通过 <code>M-x toggle-input-method</code> 切换回英文输入来 workaround ，
这样就能避开这个 bug ，继续用 keyboard macro 来编辑文本。</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> </div>
<div class="post-date">17 Feb 2019</div><h1 class="post-title"><a href="2019-01-13-understand-git-submodule.html">如何理解 Git submodule</a></h1>
<p>
Git 虽然很强大，但也有少数命令很难理解。
submodule 就是这么一个例子，其文档教程也不少，比如 <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">Git - Submodules - git-scm.com</a> ，
但我之前始终没有真正领悟到如何使用。
</p>

<p>
直到有天看了一条  <a href="https://stackoverflow.com/a/5814351/910978">StackOverflow Answer</a> ，茅塞顿开，才真正理解了 submodule 。
</p>

<p>
submodule 涉及到两个仓库类型：
</p>
<dl class="org-dl">
<dt>submodule</dt><dd>子模块，比如需要使用的第三方库</dd>
<dt>superproject</dt><dd>主仓库，自己的工程，依赖子模块代码</dd>
</dl>

<p>
Git submodule 本质上是两个独立的仓库，各自可以独立地像普通的 repo 一样操作。
同时 superproject 有一个“指针”，记录了它使用的子模块的 commit revision 。
这个“指针”对于从 SVN 转过来的同学来说会比较不适应，因为 SVN External 没有这个设计，
所以 SVN 无法精确控制所使用的子模块 revision  ，更新主仓库时会自动更新其“子模块”的代码为最新的，
如果“子模块”是外部的代码并且不稳定的话，会影响自己的代码。
</p>

<p>
带着这个认知，在 superproject 中更新 submodule 的操作步骤示意如下：
<img src="./images/2019-01-13-git-submodule-diagram.png" alt="2019-01-13-git-submodule-diagram.png">
</p>

<p>
无论是 superproject 还是 submodule ，都像普通的 repo 一样进行 branch, add, push, diff 等等的操作，
只是最后再通过 <code>git submodule</code> 命令再更新下新“指针”位置即可。</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-git.html">Git</a> </div>
<div class="post-date">22 Dec 2018</div><h1 class="post-title"><a href="2018-12-22-c-cpp-devel-with-lsp-in-emacs.html">在 Emacs 中使用 LSP 开发 C/C++ 工程</a></h1>
<p>
写代码的时候，如果能够基于当前的上下文提示补全，不仅能提高写代码的效率，还能提升体验，有种行云流水的感觉。
Emacs 中之前我用 gtags 等静态的工具来辅助写代码，最大的问题是无法根据上下文补全，体验不好。
有了 LSP 协议之后， Emacs 中现在也能实现这个功能了，体验相当不错。
前段时间折腾了一下，在此作个小结。
</p>

<p>
目前 Emacs 上有两个客户端实现： <a href="https://github.com/joaotavora/eglot">eglot</a> 和 <a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> ，由于 eglot 相对比较简洁，只需要很少的配置，因此我就选它了（暂时还没试过 lsp-mode ，等有需要时再看）。
</p>

<p>
对于服务端，目前有三个选择 clangd,  <a href="https://github.com/cquery-project/cquery">cquery</a> 和 <a href="https://github.com/MaskRay/ccls">ccls</a> ， ccls 是在 cquery 的基础之上 fork 改进的。
clangd 安装最简单，但功能据说比较弱，我没有试过；一开始我在自己电脑上编译了 ccls ，再把二进制文件拷贝到公司机器，
但是补全始终有问题（怀疑必须在使用的机器上编译，直接拷贝行不通），没有找到具体的原因；
后来在公司机器上直接编译了 cquery ，可以补全，就没有再折腾 ccls 了。
</p>

<p>
选定了客户端和服务端之后，接下来就是对具体工程的配置了， cquery 和 ccls 都要求工程根目录有 compilation database 或者 <code>.cquery</code> / <code>.ccls</code> 文件。
由于我们的工程都是用 GNU Make 进行构建的，没法使用 <code>cmake</code> 直接生成 compilation database 。
其他方案比如 <a href="https://github.com/rizsotto/Bear">Bear</a> ，由于我们的工具链太老，没有 <code>cmake</code> 无法编译 <code>Bear</code> ，因此也派不上用场。
至此由于无法生成服务器的配置文件，看来似乎与 LSP 无缘了。
</p>

<p>
后来有一天，突然想到可以直接自己解析 <code>make</code> 的输出（就用 Elisp ），解析 <code>Entering directory</code> , <code>Leaving directory</code> 以及 <code>g++</code> 编译的相关行，
提取生成为 <code>compile_commands.json</code> ，这样就无须再依赖其他软件。
但是此方法有一个缺点，在新增文件的时候，得人工在 json 文件中增加一条记录，比较麻烦，不易维护。
</p>

<p>
其实此种情况下直接用 <code>.cquery</code> 文件最好，无需指定特定的源码文件，
只需要配置编译选项以及头文件目录，因此新增文件时不需要修改。
举一个 cquery wiki 中的 <a href="https://github.com/cquery-project/cquery/wiki/.cquery">例子</a> ：
</p>

<pre class="example">
# it will expend to clang/clang++ according to the extension name
%clang

# C specific options
%c -std=gnu11

# C++ specific options
%cpp -std=gnu++14
-pthread

# Includes
-I/work/cquery/third_party
-I/work/cquery/another_third_party
# -I space_is_not_allowed
</pre>


<p>
到此似乎万事俱备，可以愉快地写代码了，最终却发现还有一个问题：由于历史原因，我们的工程源码都是使用 GBK 编码的，
但是 LSP 只支持 UTF-8 ，导致由于编码问题无法显示类、函数注释的问题，当时还在 eglot 提了一个 <a href="https://github.com/joaotavora/eglot/issues/135">issue</a> （其实不是 eglot 的问题）。
</p>

<p>
为了解决这个问题想过几种方法：
</p>
<ol class="org-ol">
<li>cquery 中在输出之前，把内容转为 UTF-8 编码（利用 <code>iconv</code> 库）</li>
<li><code>eglot</code> 在解析服务端返回的数据时，根据指定的编码进行 decode</li>
</ol>

<p>
第一种方法适用面太窄，因为 LSP 的实现还不是非常成熟，有时需要切换到 <code>ccls</code> 来体验，
这就意味着得在 <code>ccls</code> 中也用 <code>iconv</code> 再转一道，太麻烦，不符合 <code>DRY</code> 的原则。
</p>

<p>
第二种方法，需要在 <code>eglot.el</code> 和其依赖的低层通信库 <code>jsonrpc.el</code> 中同时服务端传回数据的编码方式。
当时也实现了，后来觉得不是很直接、优雅，就没再继续用了。另外，如果有一天改用 lsp-mode ，
那又需要在 lsp-mode 中做一遍类似的修改，同样也不符合 <code>DRY</code> 原则。
</p>

<p>
最后使用了适配器的 <a href="https://github.com/whatacold/lsa">方案</a> ，使用 Python 3 实现，既不动客户端也不动服务端，在中间加一层，用于转换服务端的编码。
这样就是一个比较通用的方案了，能适配所有的客户端和服务端。
</p>

<p>
在 eglot 中根据项目的编码情况（通过 <code>.dir-locals.el</code> 区分）决定是否使用此适配器：
</p>

<div class="org-src-container">
<pre class="src src-elisp">
(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">ccls-init-args</span> nil
  <span style="color: #16a085;">"Init args for ccls, e.g. '(:clang (:extraArgs (\"-std=c++03\")))"</span>)

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">eglot-ls-output-encoding</span> <span style="color: #16a085;">"utf-8"</span>
  <span style="color: #16a085;">"The LS's output encoding"</span>)

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">eglot-cpp-ls</span> <span style="color: #16a085;">"cquery"</span>
  <span style="color: #16a085;">"The language server for C/C++."</span>)

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/eglot-ccls-contact</span> (interactive-p)
  <span style="color: #16a085;">"A contact function to assemble args for ccls.</span>
<span style="color: #16a085;">Argument INTERACTIVE-P indicates where it's called interactively."</span>
  (<span style="color: #2c3e50; font-style: italic;">let</span> ((json-object-type 'plist)
        (json-array-type 'list)
        result)
    (<span style="color: #2c3e50; font-style: italic;">cond</span> ((equal <span style="color: #16a085;">"ccls"</span> eglot-cpp-ls)
           (<span style="color: #2c3e50; font-style: italic;">push</span> (format <span style="color: #16a085;">"-log-file=/tmp/ccls-%s.log"</span>
                         (file-name-base
                          (directory-file-name
                           (car
                            (project-roots
                             (project-current))))))
                 result)
           (<span style="color: #2c3e50; font-style: italic;">when</span> ccls-init-args
             (<span style="color: #2c3e50; font-style: italic;">push</span> (format <span style="color: #16a085;">"-init=%s"</span> (json-encode
                                       ccls-init-args))
                   result))
           (<span style="color: #2c3e50; font-style: italic;">push</span> <span style="color: #16a085;">"ccls"</span> result))
          ((equal <span style="color: #16a085;">"cquery"</span> eglot-cpp-ls)
           (<span style="color: #2c3e50; font-style: italic;">setq</span> result (list <span style="color: #16a085;">"cquery"</span> <span style="color: #16a085;">"--log-all-to-stderr"</span>)))
          (t <span style="color: #95a5a6; font-style: italic;">; </span><span style="color: #95a5a6; font-style: italic;">e.g. clangd</span>
           (<span style="color: #2c3e50; font-style: italic;">push</span> eglot-cpp-ls result)))
    <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">apply the adapter if necessary</span>
    (<span style="color: #2c3e50; font-style: italic;">unless</span> (equal eglot-ls-output-encoding <span style="color: #16a085;">"utf-8"</span>)
      (<span style="color: #2c3e50; font-style: italic;">dolist</span> (item (reverse (list <span style="color: #16a085;">"lsa.py"</span>
                                   (concat <span style="color: #16a085;">"--original-response-encoding="</span>
                                           eglot-ls-output-encoding)
                                   <span style="color: #16a085;">"--log-level=DEBUG"</span>
                                   <span style="color: #16a085;">"--"</span>)))
        (<span style="color: #2c3e50; font-style: italic;">push</span> item result)))
    <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">cquery should apply the specific class in eglot</span>
    (<span style="color: #2c3e50; font-style: italic;">when</span> (equal <span style="color: #16a085;">"cquery"</span> eglot-cpp-ls)
      (<span style="color: #2c3e50; font-style: italic;">push</span> 'eglot-cquery result))
    result))

(eval-after-load 'eglot
  '(<span style="color: #2c3e50; font-style: italic;">progn</span>
     (add-to-list 'eglot-server-programs
                  (cons '(c-mode c++-mode foo-mode) #'whatacold/eglot-ccls-contact))))
</pre>
</div>

<p>
至此 LSP 基本可用了。</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> <a href="tag-c++.html">C++</a> <a href="tag-python.html">Python</a> </div><div id="archive">
<a href="archive.html">Other posts</a>
</div>
</div>
</body>
</html>

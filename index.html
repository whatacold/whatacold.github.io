<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://whatacold.github.io/rss.xml"
      title="RSS feed for https://whatacold.github.io/"/>
<title>whatacold's blog site</title>
<meta name="author" content="Guangwang Huang">
<meta name="referrer" content="no-referrer">
<link href= "static/style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="header">
<div class="sitelinks">
    <a href="https://github.com/whatacold">GitHub</a> | <a href="https://stackoverflow.com/users/910978/whatacold">Stack Overflow</a> | <a href="mailto:whatacold@gmail.com">Email</a> | <a href="/rss.xml">RSS</a>
</div></div>
<div id="content">

<div class="post-date">20 Jul 2019</div><h1 class="post-title"><a href="2019-07-20-generating-org-mode-outlines-for-wikihow-articles.html">Generating org-mode outlines for wikiHow articles</a></h1>
<p>
Recently I found some great articles on <a href="https://www.wikihow.com">wikiHow</a>, then I want to keep notes of them in org-mode files.
</p>

<p>
At first, I manually copied the ToC of articles, but soon I found it's tedious and takes a lot of time.
Today I wrote a Python script to help me extract the ToCs into org-mode outlines. It takes two arguments, the first one is the URL, the second one is the containing heading's level for the generated ToC in org-mode.
</p>

<p>
For example, I can run it from within an org-mode file under a heading called <code>* Test</code>, by executing <code>M-x python wikihow-org-outline.py https://www.wikihow.com/Improve-Your-English 1</code>, then the output outline will be put under the <code>* Test</code> heading.
</p>

<p>
Here is the source code:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #95a5a6; font-style: italic;">#</span><span style="color: #95a5a6; font-style: italic;">!/usr/bin/env python</span>
<span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">-*- coding: utf-8 -*-</span>

<span style="color: #2c3e50; font-style: italic;">from</span> bs4 <span style="color: #2c3e50; font-style: italic;">import</span> BeautifulSoup
<span style="color: #2c3e50; font-style: italic;">import</span> requests
<span style="color: #2c3e50; font-style: italic;">import</span> sys

<span style="color: #2c3e50; font-style: italic;">def</span> <span style="color: #9b59b6;">gen_wikihow_org_outline</span>(url, containing_heading_level=0):
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #16a085;">'''Generating a org outline for the specified article at URL.'''</span>
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">user_agent</span>=<span style="color: #16a085;">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36"</span>
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">headers</span>={<span style="color: #16a085;">"User-Agent"</span>:user_agent}
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">html</span> = requests.get(url, headers=headers).content

<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">soup</span> = BeautifulSoup(html, <span style="color: #16a085;">"html.parser"</span>)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">level_prefix</span> = <span style="color: #16a085;">'*'</span> * containing_heading_level

<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">title</span> = soup.select(<span style="color: #16a085;">"h1 &gt; a"</span>)[0].get_text()
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">print</span>(<span style="color: #16a085;">"{}* [[{}][{}]]"</span>.<span style="color: #2c3e50;">format</span>(level_prefix, url, title))

<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">sections</span> = soup.select(<span style="color: #16a085;">"h3 &gt; span"</span>)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">for</span> section <span style="color: #2c3e50; font-style: italic;">in</span> sections:
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">print</span>(<span style="color: #16a085;">"{}** {}"</span>.<span style="color: #2c3e50;">format</span>(level_prefix, section.get_text()))
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">subsections</span> = section.parent.parent.find_all(<span style="color: #16a085;">"b"</span>, class_=<span style="color: #16a085;">"whb"</span>)
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">for</span> subsection <span style="color: #2c3e50; font-style: italic;">in</span> subsections:
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">subsection_title</span> = subsection.get_text()
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">if</span> <span style="color: #2c3e50;">len</span>(subsection_title) &lt; 3:
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">continue</span> <span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">it may contain only ".", just work around it.</span>
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">print</span>(<span style="color: #16a085;">"{}*** {}"</span>.<span style="color: #2c3e50;">format</span>(level_prefix, subsection_title))

<span style="color: #3498db;">containing_heading_level</span>=0

<span style="color: #2c3e50; font-style: italic;">if</span> <span style="color: #2c3e50;">len</span>(sys.argv) &lt; 2:
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">print</span>(<span style="color: #16a085;">"Usage: {} &lt;url&gt; [containing heading level]"</span>.<span style="color: #2c3e50;">format</span>(sys.argv[0]))
<span style="background-color: #ecf0f1;"> </span>   sys.<span style="color: #7f8c8d; font-style: italic;">exit</span>(1)

<span style="color: #3498db;">url</span> = sys.argv[1]
<span style="color: #2c3e50; font-style: italic;">if</span> <span style="color: #2c3e50;">len</span>(sys.argv) == 3:
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">containing_heading_level</span> = <span style="color: #2c3e50;">int</span>(sys.argv[2])

gen_wikihow_org_outline(url, containing_heading_level)
</pre>
</div>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-org-mode.html">Org-mode</a> </div>
<div class="post-date">20 Jul 2019</div><h1 class="post-title"><a href="2019-07-20-understanding-align-regexp-of-emacs.html">Understanding align-regexp of Emacs</a></h1>
<p>
Emacs' <code>M-x align-regex</code> is neat when I want to align some similar text, especially when we're coding.
I use its trivial version(without prefix arg) regularly on day-to-day programming work before.
</p>

<p>
For example, I can use it to align below code quickly by:
</p>
<ol class="org-ol">
<li>Choose the region</li>
<li><code>M-x align-regexp</code> and type <code>=</code> and <code>Enter</code></li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #3498db;">aaaaaaaaaaaaaa</span> = fields[0]
<span style="color: #3498db;">bbb</span> = fields[1]
<span style="color: #3498db;">cccccccc</span> = fields[2]
</pre>
</div>

<p>
It will be aligned to below code, now it's better to read:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3498db;">aaaaaaaaaaaaaa</span> = fields[0]
<span style="color: #3498db;">bbb</span>            = fields[1]
<span style="color: #3498db;">cccccccc</span>       = fields[2]
</pre>
</div>

<p>
A few days ago, I found I didn't understand how it works when I read the code of <a href="https://github.com/manateelazycat/smart-align">smart-align</a>, A simple <code>align-regexp</code> wrapper for easier usage.
I was confused by the parameters, especially <code>REGEXP</code> and <code>GROUP</code>, and <code>SPACING</code>, here is the defun signature:
</p>

<pre class="example">
(align-regexp BEG END REGEXP &amp;optional GROUP SPACING REPEAT)
</pre>

<p>
As for <code>REGEXP</code> and <code>GROUP</code>, as in the above example, I think the regexp should be <code>\(\s-*=\)</code>, so that group 1 will be aligned by prepending spaces.
In fact, it resulted in removing the <code>=</code> for the first line, so I was wrong. The correct regex for it is <code>\(\s-*\)=</code>.
</p>

<p>
After reading a related thread <sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> on Emacs Stack Exchange for many times and practicing it along the way, I finally figured out, <b>the key to understanding it</b> is that it works by matching the specified group pattern, then appending it with whitespaces or removing extra whitespaces, so that the alignment character after it, <code>=</code> in this case, will be aligned.
</p>

<p>
As for the <code>SPACING</code>, it means how many spaces should be kept for the "densest" line, 1 will result in <code>aaaaaaaaaaaaaa = fields[0]</code>, 2 will result in <code>aaaaaaaaaaaaaa  = fields[0]</code>, as so on.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
The link is: <a href="https://emacs.stackexchange.com/questions/2644/understanding-of-emacs-align-regexp">https://emacs.stackexchange.com/questions/2644/understanding-of-emacs-align-regexp</a></p></div></div>


</div>
</div><div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> </div>
<div class="post-date">06 Jul 2019</div><h1 class="post-title"><a href="2019-07-06-render-erd-on-the-web.html">Preview erd on the web</a></h1>
<p>
If you ever wonder how to plot ER diagrams in plain text, you may have already heard of <a href="https://github.com/BurntSushi/erd">erd</a>.
It's a cool command line program written by Andrew Gallant in Haskell, to "compile" plain text files into nicely looking images,
leveraging the power of GraphViz.
</p>

<p>
I've used erd for some time, it's cool and the syntax is quite simple.
It's also quite simple to install it on Linux, just install GraphViz and erd itself,
by following the instructions in the README page.
</p>

<p>
But there are times that there isn't an erd environment at hand:
</p>
<ul class="org-ul">
<li>erd is hard to install, or we don't have the permission to install it.</li>
<li>I shared the plain text file with my teammates, but they didn't know how to convert it to an image.</li>
</ul>

<p>
So I think maybe it's useful to have a web application that folks can try it out online,
here it is: <a href="https://serene-forest-18642.herokuapp.com/">erd-repl</a> , a simple Flask application hosted on Heroku.
Although the name REPL, it's far from being a REPL, I think that a REPL helps ease the learning process, be it Emacs REPL, or Python REPL, as it gives you feedback as you type.
</p>

<p>
It's so simple that there isn't any user authentication mechanism, and here are some caveats:
</p>
<ul class="org-ul">
<li>the "source code" of plain text is simply stored in the browser cookie, together with your id.</li>
<li>no edit features, you need to edit it somewhere, e.g. Emacs, and then copied to erd-repl if it's complex, to prevent data loss.</li>
<li>only one image is stored per one user.</li>
<li>imaged will be cleared if being not touched for a few days</li>
</ul>

<p>
After hosting it on Heroku, I found that there is an <a href="https://github.com/BurntSushi/erd/issues/1">issue</a> discussing hosting a web service of erd on GitHub,
take a look too if you're interested.
</p>

<p>
P.S. I know the UI is ugly. I have basic knowledge of CSS, but I just don't have the sense to layout elements properly, what materials/practices would you recommend improving my front end skill at this stage? or any tips on the UI itself?</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-python.html">Python</a> <a href="tag-tools.html">Tools</a> </div>
<div class="post-date">10 Mar 2019</div><h1 class="post-title"><a href="2019-02-24-fine-tune-curly-brace-style-of-yasnippet-snippet-on-the-fly.html">Fine-tune curly braces style of yasnippet snippet on the fly</a></h1>
<p>
<a href="https://github.com/joaotavora/yasnippet">Yasnippet</a> is a good friend to help us type less and write more, whenever we write some text snippets repeatedly. And there is also an official repository called <a href="https://github.com/AndreaCrotti/yasnippet-snippets">yasnippet-snippets</a> that contains various snippets for many programming languages(modes), so that we can have many snippets in no time by installing it.
</p>

<p>
But there is a little problem when it comes to conform to different coding styles. Take the <code>if</code> snippet for example, normally it will generate code like this:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #2c3e50; font-style: italic;">if</span> (a) {
    do_something();
}
</pre>
</div>

<p>
This is fine for a K&amp;R style project, but will be kind of annoyed if we work on an allman style project,
because we need to fine-tune the style for every <code>if</code> clauses generated to like this:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #2c3e50; font-style: italic;">if</span> (a)
{
    do_something();
}
</pre>
</div>

<p>
How to fine-tune the coding styles according to the project requirement? Or at least curly braces styles, which is the one that matters most for me.
</p>

<p>
Maintaining two similar copies for every snippet is obviously not a good option, it's daunting and boring.
</p>

<p>
Fortunately, yasnippet provides a hook called <code>yas-after-exit-snippet-hook</code>, which I can take advantage of to adjust the curly braces style when needed. Below is a trivial hook that I come up with, it assumes that the snippets are in K&amp;R style, which is the style that yasnippet-snippet takes, and I prepend <code>{</code> with newlines and surround <code>}</code> with newlines when this behaviour is asked by setting <code>(setq whatacold/yasnippet-c-style 'allman)</code> .
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/style-braces-in-allman</span> (snippet)
  <span style="color: #16a085;">"Style the SNIPPET in allman brace style.</span>

<span style="color: #16a085;">There are roughly 3 basic brace styles:</span>
<span style="color: #16a085;">- Attached: The braces are attached to the end of the last line of the previous block. (Java).</span>
<span style="color: #16a085;">- Broken: The braces are broken from the previous block. (Allman).</span>
<span style="color: #16a085;">- Linux: The braces are attached except for the opening brace of a function, class, or namespace (K&amp;R, Linux).</span>

<span style="color: #16a085;">http://astyle.sourceforge.net/astyle.html#_Basic_Brace_Styles"</span>
  (<span style="color: #2c3e50; font-style: italic;">let</span> ((len (length snippet))
        (i 0)
        chars char new-str)
    (<span style="color: #2c3e50; font-style: italic;">while</span> (&lt; i len)
      (<span style="color: #2c3e50; font-style: italic;">setq</span> char (aref snippet i))
      (<span style="color: #2c3e50; font-style: italic;">case</span> char
        (?{
         (<span style="color: #2c3e50; font-style: italic;">push</span> ?\n chars)
         (<span style="color: #2c3e50; font-style: italic;">push</span> char chars))
        (?}
         (<span style="color: #2c3e50; font-style: italic;">push</span> ?\n chars)
         (<span style="color: #2c3e50; font-style: italic;">push</span> char chars)
         (<span style="color: #2c3e50; font-style: italic;">push</span> ?\n chars))
        (t
         (<span style="color: #2c3e50; font-style: italic;">push</span> char chars)))
      (<span style="color: #2c3e50; font-style: italic;">setq</span> i (1+ i)))
    (<span style="color: #2c3e50; font-style: italic;">setq</span> new-str (replace-regexp-in-string <span style="color: #16a085;">"[\n \t]+\n"</span>
                                            <span style="color: #16a085;">"\n"</span>
                                            (apply #'string (nreverse chars))))
    new-str))

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">whatacold/yasnippet-c-style</span> nil
  <span style="color: #16a085;">"Style of curly braces, e.g. 'allman."</span>
  <span style="color: #2c3e50;">:type</span> '(symbol))

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/yasnippet-exit-hook-c</span> ()
  (<span style="color: #2c3e50; font-style: italic;">let*</span> ((text-marker <span style="color: #16a085;">"the-yasnippet-exit-point;"</span>) <span style="color: #95a5a6; font-style: italic;">; </span><span style="color: #95a5a6; font-style: italic;">workaround. text property is more elegant.</span>
         (begin yas-snippet-beg)
         (end yas-snippet-end)
         (snippet (buffer-substring-no-properties begin end))
         new-snippet)
    (<span style="color: #2c3e50; font-style: italic;">when</span> (<span style="color: #2c3e50; font-style: italic;">and</span> (string-match <span style="color: #16a085;">"[{}]"</span> snippet)
               (eq 'allman whatacold/yasnippet-c-style))
      (insert text-marker)
      (<span style="color: #2c3e50; font-style: italic;">setq</span> end (+ yas-snippet-end (length text-marker)))

      (<span style="color: #2c3e50; font-style: italic;">setq</span> snippet (buffer-substring-no-properties begin end)) <span style="color: #95a5a6; font-style: italic;">; </span><span style="color: #95a5a6; font-style: italic;">re-fetch content</span>
      (<span style="color: #2c3e50; font-style: italic;">setq</span> new-snippet (whatacold/style-braces-in-allman snippet))
      (delete-region begin end)
      (insert new-snippet)

      (goto-char begin)
      <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">re-indent it in the context</span>
      (indent-region begin (+ end (- (length new-snippet)
                                     (length snippet))))
      (re-search-forward text-marker)
      (delete-char (- 0 (length text-marker))))))

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/yasnippet-exit-hook</span> ()
  <span style="color: #16a085;">"My yasnippet exit hook."</span>
  (<span style="color: #2c3e50; font-style: italic;">case</span> major-mode
    ((c-mode c++-mode)
     (whatacold/yasnippet-exit-hook-c))))

<span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">see https://github.com/joaotavora/yasnippet/issues/728</span>
(add-to-list 'yas-after-exit-snippet-hook #'whatacold/yasnippet-exit-hook)
</pre>
</div>

<p>
Now the coding experience is much better :)</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> </div>
<div class="post-date">17 Feb 2019</div><h1 class="post-title"><a href="2019-02-03-emacs-kmacro-characters-repeated-bug.html">记一个 Emacs Keyboard Macro 输入字符重复的 Bug</a></h1>
<p>
工作中不时地会使用 Emacs keyboard macro 来解决重复性的编辑任务，
但有时录制了再重放却出现输入的字符被重复了，导致出现非预期的结果。
一般此时为了赶进度，只好忍了，放弃 keyboard macro ，通过其他方式编辑了。
</p>

<p>
诡异的是等到有空闲的时候尝试重现却又重现不了，还一度以为是由于 keyboard macro 不支持输入 <code>M-x</code> 命令导致的，
但又没看到其他 Emacser 提到有此限制。
</p>

<p>
问题虽然偶尔才出现，但是一旦出现，工作流会被打断，很让人苦恼。
好在春节期间终于被我重现出来了，在启用 <a href="https://github.com/tumashu/pyim">pyim</a> 输入法的情况下必现，比如在录制时输入 <code>nihao</code> 得到了 <code>你好</code> ，
但是在 replay keyboard macro 的时候，得到的效果却相当于人工输入了 <code>nniihhaaoo</code> ，每个输入字符都被重复了一次，
自然就没法得到 <code>你好</code> 二字，详细的重现步骤见这个 pyim <a href="https://github.com/tumashu/pyim/issues/247">issue</a> 。
</p>

<p>
@tumashu 帮忙确认了 Emacs 自带的 quail-chinese 输入法也有此问题，建议我去 mailing list 问下看看。
最后 Emacs maintainer Eli Zaretskii 在 <a href="http://lists.gnu.org/archive/html/bug-gnu-emacs/2019-02/msg00391.html">这个 thread</a> 告知半年前已经有人在 <a href="https://debbugs.gnu.org/cgi/bugreport.cgi?bug=32108">Bug #32108</a> 中报告了，
且已经在 master 中修复了（ <a href="https://github.com/emacs-mirror/emacs/commit/03e3440dbbfea40b449a9f6f23a3630664275d11">commit 03e3440dbbfea40b449a9f6f23a3630664275d11</a> ），将会包含在 Emacs 27 发布中。
</p>

<p>
修复原理大致是在内核中增加一个标记 <code>inhibit--record-char</code> ，由输入法根据情况设置为 <code>t/nil</code> ，
当值为 <code>t</code> 时内核不会把事件记录到 <code>last-kbd-macro</code> 中（见 <code>record-char</code> 函数），
这样输入法出于实现需要重放的用户输入字符，就不会被重复记录到 keyboard macro 中。
</p>

<p>
Emacs 自带的输入法虽然已经解决了问题，但是 pyim 还没解决，接下来如果有时间再研究下如何解决（ Emacs 27 已经编译好了 :) ），
在彻底解决之前，如果在录制 keyboard macro 时不需要输入中文，可以通过 <code>M-x toggle-input-method</code> 切换回英文输入来 workaround ，
这样就能避开这个 bug ，继续用 keyboard macro 来编辑文本。</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> </div><div id="archive">
<a href="archive.html">Other posts</a>
</div>
</div>
</body>
</html>

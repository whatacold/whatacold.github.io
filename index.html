<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://whatacold.github.io/rss.xml"
      title="RSS feed for https://whatacold.github.io/"/>
<title>whatacold's blog site</title>
<meta name="author" content="Guangwang Huang">
<meta name="referrer" content="no-referrer">
<link href= "static/style.css" rel="stylesheet" type="text/css" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-74588785-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-74588785-1');
</script>
</head>
<body>
<div id="preamble" class="status"><div class="header">
<div class="sitelinks">
    <a href="https://github.com/whatacold">GitHub</a> | <a href="https://stackoverflow.com/users/910978/whatacold">Stack Overflow</a> | <a href="mailto:whatacold@gmail.com">Email</a> | <a href="/rss.xml">RSS</a>
</div></div>
<div id="content">

<div class="post-date">25 Jun 2020</div><h1 class="post-title"><a href="2020-06-25-is-it-safe-to-use-redis-as-a-data-store.html">Is it safe to use Redis as a data store?</a></h1>
<p>
Traditionally we are used to storing data in an RDBMS like MySQL, and avoid using in-memory solutions such as Redis, to have a confidence of no data loss. Sometimes I find that we are so stubborn with MySQL that ending up with a complicated design, and I've even seen a solution that stores data in MySQL and then using Redis as a cache for it to improve read performance in the meanwhile. And to make the data in the cache as consistent as possible with the data in MySQL, it introduces other mechanisms, but the result is still not 100% consistent.
</p>

<p>
So I wonder, is it safe to use Redis as a data store directly? Since if that's OK, we can have a clean solution without using MySQL for, at least, the above scenario.
</p>

<p>
Redis has two data <a href="https://redis.io/topics/persistence">persistence</a> solutions: the RDB persistence and AOF persistence. The RDB persistence is suitable for making complete point-in-time backups every a few minutes, which can be configured via the <code>save</code> directive. And the AOF persistence is finer-grained, as it logs every command that it executes, and there are three options for how frequent it flushes (<code>[[https://man7.org/linux/man-pages/man2/fsync.2.html][fsync]]</code>'ing in the syscall level) the AOF file to the disk (the <code>appendfsync</code> option):
</p>

<ul class="org-ul">
<li>always: <code>fsync</code> every time a new command is appended to the AOF.</li>
<li>everysec: <code>fsync</code> every second.</li>
<li>no: Never <code>fsync</code>, it's up to the OS when to fsync the file.</li>
</ul>

<p>
So the answer is yes, for a situation that Redis is more suitable to organize the data in a NoSQL style. Use <code>always</code> for <code>appendfsync</code> if we can't tolerate any data loss, and use <code>everysec</code> if the data is not that important, and we can endure a second of data loss, at most.
</p>

<p>
As a comparison, MySQL has a similar mechanism called binary log (binlog) to log its SQL statements, and there is also a configuration directive, <a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_sync_binlog">sync_binlog</a>, to control how often it <code>fsync</code>'s:
</p>
<ul class="org-ul">
<li>0, never <code>fsync</code> explicitly</li>
<li>1, <code>fsync</code> every statement</li>
<li>N (N&gt;1), <code>fsync</code> every N statements</li>
</ul>

<p>
So it's OK to use Redis as a data store with the AOF persistence enabled, it can be as safe as MySQL in theory.
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-redis.html">Redis</a> <a href="tag-mysql.html">MySQL</a> </div>
<div class="post-date">30 May 2020</div><h1 class="post-title"><a href="2020-05-30-a-trick-to-troubleshoot-emacs-subprocess-creating.html">A Trick to Troubleshoot Emacs Subprocess Creating</a></h1>
<p>
There are many packages of Emacs that leverage subprocesses to do their jobs, <a href="https://magit.vc/">Magit</a>, <a href="https://github.com/joaotavora/eglot">eglot</a>, <a href="https://github.com/jorgenschaefer/elpy">elpy</a>, to name a few. And there are times that a subprocess doesn't work as expected, for example, Magit is slow, and you're sure that it's ok when running git commands on shell. So how to spot these problems effectively and quickly?
</p>

<p>
The problem is that we don't know what's going on exactly, so here I want to share a few Elisp advice to make the subprocess creating visible, and print the exact program and its arguments to the <code>*Message*</code> buffer. Visibility is the key.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #2c3e50; font-style: italic;">defvar</span> <span style="color: #3498db;">trace-subprocess-p</span> nil
  <span style="color: #16a085;">"Whether to trace subprocess creating or not."</span>)

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">my-toggle-trace-subprocess</span> ()
  <span style="color: #16a085;">"Toggle whether to trace subprocess creating."</span>
  (<span style="color: #2c3e50; font-style: italic;">interactive</span>)
  (<span style="color: #2c3e50; font-style: italic;">setq</span> trace-subprocess-p (not trace-subprocess-p))
  (<span style="color: #2c3e50; font-style: italic;">when</span> trace-subprocess-p
    (message <span style="color: #16a085;">"Trace subprocess creating."</span>)))

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">my-quote-argument</span> (arg)
  <span style="color: #16a085;">"Double quote ARG."</span>
  (concat <span style="color: #16a085;">"\""</span> arg <span style="color: #16a085;">"\""</span>))

(<span style="color: #2c3e50; font-style: italic;">define-advice</span> <span style="color: #9b59b6;">start-process</span> (<span style="color: #2c3e50;">:before</span> (name buffer program <span style="color: #27ae60;">&amp;rest</span> program-args) trace)
  (<span style="color: #2c3e50; font-style: italic;">when</span> trace-subprocess-p
    (message <span style="color: #16a085;">"Trace start-process: name: %s, buffer: %s, program and args: %s %s"</span>
             name buffer program
             (mapconcat #'my-quote-argument program-args <span style="color: #16a085;">" "</span>))))

(<span style="color: #2c3e50; font-style: italic;">define-advice</span> <span style="color: #9b59b6;">shell-command-to-string</span> (<span style="color: #2c3e50;">:before</span> (command) trace)
  (<span style="color: #2c3e50; font-style: italic;">when</span> trace-subprocess-p
    (message <span style="color: #16a085;">"Trace shell-command-to-string: %s"</span> command)))

(<span style="color: #2c3e50; font-style: italic;">define-advice</span> <span style="color: #9b59b6;">call-process</span> (<span style="color: #2c3e50;">:before</span> (program <span style="color: #27ae60;">&amp;optional</span> infile destination display <span style="color: #27ae60;">&amp;rest</span> args) trace)
  (<span style="color: #2c3e50; font-style: italic;">when</span> trace-subprocess-p
    (message <span style="color: #16a085;">"Trace call-process: %s %s"</span>
             program
             (mapconcat #'my-quote-argument args <span style="color: #16a085;">" "</span>))))
</pre>
</div>

<p>
Add these to your <code>.emacs.d</code> and type <code>M-x my-toggle-trace-subprocess RET</code> when you want to see what is going on under the neath. The following is how it looks like when I run <code>M-x elpy-mode</code> on a Python buffer:
</p>

<pre class="example">
Trace start-process: name:  *elpy-rpc [project:~/python/qtile/ environment:/home/whatacold/virtualenv/elpy]*, buffer:  *elpy-rpc [project:~/python/qtile/ environment:/home/whatacold/virtualenv/elpy]*, program and args: /home/whatacold/.emacs.d/elpy/rpc-venv/bin/python "-W" "ignore" "-m" "elpy.__main__"
</pre>

<p>
With the help of these advice, I successfully resolved a performance issue of Magit with a particular repo the other day, which was caused by <a href="https://github.com/emacsorphanage/magit-svn">magit-svn</a> hooks.
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> <a href="tag-troubleshooting.html">troubleshooting</a> </div>
<div class="post-date">11 Apr 2020</div><h1 class="post-title"><a href="2020-04-11-use-ppcompile-to-remote-compile-in-emacs-zh.html">Emacs 中使用 ppcompile 进行远程编译</a></h1>
<p>
不同于 Python 之类的项目， C/C++ 的项目需要有专门的编译环境，一般国内公司都会搭建特定的编译环境机器，把一些私有的库等依赖放在上面。而这些编译环境的工具链一般都比较老旧，有的编译环境可能还无法访问外网，甚至也没有提供代理间接访问外网。因此想要在这样的环境中使用 Emacs 开发代码着实不是一件容易的事。
</p>

<p>
一个可行的方法是在自己的工作机器上维护一个开发环境跑 Emacs ，需要编译的时候把代码同步到编译机器（使用 sshfs 、 sftp 等），编译过程中发现的编译问题，在本地修复好之后，再次同步，如此往复。
</p>

<p>
但是有一个问题，整个流程太过繁琐，需要不停地手工同步。即使像 sshfs 这样无须同步的方式，在本地编辑时偶尔卡顿会比较明显。最让人无法接受的是，在修复编译的过程中，需要手工定位到具体的文件及行数，繁琐而且效率低。
</p>

<p>
你可能会说为什么不用 Tramp 模式直接在远端的编译环境中直接编辑文件呢？的确， Tramp 编辑代码没有问题，体验也挺流畅的，但它无法解决你无法自由控制远端环境这个缺点，比如你想集成 <code>ag/rg</code> 到 Emacs 中，光安装程序可能就很折腾；而且如果公司有多套编译环境时，每个环境都维护 Emacs 会是一个麻烦。
</p>

<p>
经过一段时间的摸索，我感觉自己还是比较喜欢在本地编辑然后同步代码编译这种方式，这个过程可以自动化。另外很重要的一点需求是，它需要能够像 <code>M-x compile</code> 那样在 Emacs 中很方便地使用 <code>M-x next-error</code> and <code>M-x previous-error</code> 来自动定位编译有问题的代码行，这样不仅提高修复编译错误的效率，还能保护视力。
</p>

<p>
按照上述思路我最终写了这样一个小插件 <a href="https://github.com/whatacold/ppcompile">ppcompile</a> ， pp 二字代表 ping-pong ，表示每次编译就像打乒乓球一样。本地先发球，利用 rsync 把代码同步到远端，远端编译之后回球，然后本地再转换 <code>*compilation*</code> buffer 中远端的路径，这样 Emacs 就能够正确地识别编译错误，从而帮助我直接打开对应的错误文件及行数。
</p>

<p>
使用方式上，只需要把 <code>ppcompile.el</code> 拷贝到 load-path 中进行加载，然后设置一些选项即可。具体可以参考项目 README 。当前提供以下几个命令：
</p>
<ol class="org-ol">
<li><code>ppcompile-ping</code> 仅同步代码到远端</li>
<li><code>ppcompile-pong</code> 仅在远端编译</li>
<li><p>
<code>ppcompile</code> 同步代码以及编译，即一次 ping-pong 往返。
</p>

<p>
这个命令和 <code>ppcompile-pong</code> 命令在使用上同时考虑了 compile 命令的使用习惯，会遵循你的 <code>compilation-read-command</code> 设置决定是否编译时弹窗让你选择编译命令。
</p></li>

<li><code>ppcompile-config-project</code> 配置项目配置到根目录的 <code>.dir-locals.el</code> 中，主要是为了方便有很多项目时的个性化定制需求，否则直接配置全局的就可以了。</li>

<li><code>ppcompile-toggle-debug</code> 调试开关命令，在开启的情况下会把当前执行的命令行打印到 <code>*Message*</code> 中。</li>
</ol>

<p>
目前，我自己使用 ppcompile 已经没有什么问题了，它在最近的项目开发中帮我节省了不少精力，欢迎大家试用和使用 :)
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">emacs</a> <a href="tag-zhongwen.html">zhongwen</a> </div>
<div class="post-date">07 Mar 2020</div><h1 class="post-title"><a href="2020-03-07-ppcompile:-an-emacs-package-to-help-stay-coding-locally.html">ppcompile: An Emacs Package to Help Stay Coding Locally</a></h1>
<p>
If you are a C/C++ programmer like me, you may experience jumping around different machines to write and compile your code, or you may write code on different machines for different projects, and scp/rsync/ftp the projects around. It works, but it's a bit tedious and takes too much burden on our brains.
</p>

<p>
For example, say I have two projects that should be compiled on their compiling machines respectively. There are two obvious workflows for writing code for them "simultaneously":
</p>

<ol class="org-ol">
<li><p>
Write code locally, rsync files to their compiling machine and compile them, fix errors according to the compiling result.
</p>

<p>
Pros: I have only one coding environment to maintain, and I have full control of it. Install packages? Start some services? No problem, just a few commands.
</p>

<p>
Cons: I have to sync the source code, spot the errors by my eyes and fix them accordingly.
</p></li>

<li><p>
Write code on the compiling machine, compile them and fix errors locally there, taking the advantage of <code>M-x next-error</code>.
</p>

<p>
Pros: <code>M-x next-error</code> works like a charm to fix errors, just a piece of cake. Eye friendly.
</p>

<p>
Cons: Several Emacs environment to maintain, and I don't always have the root privilege.
</p>

<p>
Update: Tramp is a built-in package for editing remote files, which also falls into this category, although it's quite handy to edit single files like confs, at least for me.
</p></li>
</ol>

<p>
(Update: There is another option using <a href="https://github.com/libfuse/sshfs">sshfs</a>, which mounts the remote FS, it's a general and nice solution if you have a stable network.)
</p>

<p>
So I was wondering if there is a way to take the good part of both approaches so that I have the full privilege and fix compiling errors locally as if I were compiling locally? Well, the answer was yes, and <a href="https://github.com/whatacold/ppcompile">ppcompile</a> was my solution for it.
</p>

<p>
<code>ppcompile</code> stands for ping-pong compile, as it works like playing ping-pong. First, it rsync's the files to the compiling machines ("ping"). Second, it gets the result back ("pong") and gets them fixed locally.
</p>

<p>
It works now, and I hope it helps you too. :)</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-emacs.html">Emacs</a> </div>
<div class="post-date">04 Feb 2020</div><h1 class="post-title"><a href="2020-02-04-binary-search-algorithm-is-also-an-efficient-strategy-for-narrowing-down-problem-space.html">The binary search algorithm is also an efficient strategy for narrowing down problem space</a></h1>
<p>
<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Binary search algorithm</a> is a search algorithm that finds the position of a target value within a sorted array. It cuts off the target array in half in a pass, so that it has a worst-case performance of <code>O(log n)</code>.
</p>


<figure>
<object type="image/svg+xml" data="https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>

<figcaption><span class="figure-number">Figure 1: </span>Visualization of the binary search algorithm where 7 is the target value(@wikipedia)</figcaption>
</figure>

<p>
We all know that it's an efficient searching algorithm, but the strategy behind it also applies for narrowing down other problem space, for example, finding out when a bug is first introduced in a series of git commits.
</p>

<p>
Let's say I have a git repo of 8 commits, the first 5 of which are good, but then the 6th commit introduces a bug, so I have a git commit history looks like below:
</p>
<pre class="example">
 |g|g|g|g|g|b|b|b|
---------------------&gt; the git commit history
</pre>

<p>
So I know that the first commit is good and the last (8th) commit is bad (these are initial problem space), by leveraging the strategy of binary search, it can quickly find out that the 6th commit is the first bad commit. (Check the 4th element first, then the 6th.)
</p>

<p>
Well, that's basically how <code>git bisect</code> works, and it's more powerful, it can be run with a script to determine if current commit is good or not, saving time to verify it manually.
</p>

<p>
Recently, I managed to use <code>git bisect</code> to find out a recession bug <a href="https://github.com/qtile/qtile/issues/1410">(#1410)</a> of qtile, which reports that <code>qtile-cmd</code> doesn't work anymore which the HEAD commit (<code>0617235c</code>), but it works with tag <code>v0.14.2</code>.
</p>

<p>
With those in mind, here are the steps to catch the first bad commit:
</p>
<ol class="org-ol">
<li><p>
Start the bisect session: <code>git bisect start 0617235c v0.14.2</code>
</p>

<pre class="example">
$ git bisect start 0617235c v0.14.2
Bisecting: 88 revisions left to test after this (roughly 7 steps)
[082e4c7248ac40b69dbe94cfdc4de6aecc5f74ba] Fix debian version
</pre></li>

<li><p>
Make a judge script(attached at the end) and find out the commit by running <code>git bisect run ./scripts/git-bisect-judge</code>
</p>

<p>
It only takes git 6 steps to find the first broken commit, the output is following with qtile logs being removed:
</p>
<pre class="example">
$ git bisect run ./scripts/git-bisect-judge
running ./scripts/git-bisect-judge
Bisecting: 44 revisions left to test after this (roughly 6 steps)
[fdb3a324aadb0f934080a703d6835a9a7d203720] Delay power renormalization
running ./scripts/git-bisect-judge
...

Bisecting: 21 revisions left to test after this (roughly 5 steps)
[0262fbc2ca23d27fa33c4903d7e8a9b8c14d42eb] Move around modules
running ./scripts/git-bisect-judge
...

Bisecting: 10 revisions left to test after this (roughly 4 steps)
[a3ae3c623859b247813fc1876b188c4d40e84df0] Move calls out of the command graph
running ./scripts/git-bisect-judge
...

Bisecting: 5 revisions left to test after this (roughly 3 steps)
[036dbcb1b7c5c0fff00fbfbb9688597e2d2f188c] Add tests to the command graph
running ./scripts/git-bisect-judge
...

Bisecting: 2 revisions left to test after this (roughly 1 step)
[9c3c78ca66905b4e11bfd7a155cfe883cbe12ad6] Create new command graph
running ./scripts/git-bisect-judge
...

Bisecting: 0 revisions left to test after this (roughly 0 steps)
[ed5eefbf3482481c1f0f4c1cb2eb79e571fec835] Use correct type annotations in IPC module
running ./scripts/git-bisect-judge
...

ed5eefbf3482481c1f0f4c1cb2eb79e571fec835 is the first bad commit
commit ed5eefbf3482481c1f0f4c1cb2eb79e571fec835
Author: Sean Vig &lt;sean.v.775@gmail.com&gt;
Date:   Wed Jun 19 22:33:45 2019 -0400

    Use correct type annotations in IPC module

    With python/typeshed#3061 making it into the most recent release of
    mypy, remove the hacks on the type annotations around the marshal
    module.

:040000 040000 d21cc05b503a0f4658647adad3169efbd84eaa16 f80f29304abd86da9299dfaf22f6719698a37e63 M	libqtile
bisect run success
</pre></li>

<li>End the session by running <code>git bisect reset</code>, git will restores your previouse HEAD commit.</li>
</ol>

<p>
The judge script <code>git-bisect-judege</code> is below:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #95a5a6; font-style: italic;">#</span><span style="color: #95a5a6; font-style: italic;">!/bin/</span><span style="color: #2c3e50; font-style: italic;">sh</span>

<span style="color: #3498db;">HERE</span>=$(dirname $(readlink -f $<span style="color: #3498db;">0</span>))
<span style="color: #3498db;">SCREEN_SIZE</span>=${<span style="color: #3498db;">SCREEN_SIZE</span>:-1000x800}
<span style="color: #3498db;">XDISPLAY</span>=${<span style="color: #3498db;">XDISPLAY</span>:-:1}
<span style="color: #3498db;">LOG_LEVEL</span>=${<span style="color: #3498db;">LOG_LEVEL</span>:-DEBUG}
<span style="color: #3498db;">LOG_LEVEL</span>=INFO
<span style="color: #2c3e50; font-style: italic;">if</span> [[ -z $<span style="color: #3498db;">PYTHON</span> ]]; <span style="color: #2c3e50; font-style: italic;">then</span>
    <span style="color: #3498db;">PYTHON</span>=python
<span style="color: #2c3e50; font-style: italic;">fi</span>

./scripts/ffibuild

<span style="color: #3498db;">CLIENT</span>=<span style="color: #16a085;">"urxvt"</span>

Xephyr +extension RANDR -screen ${<span style="color: #3498db;">SCREEN_SIZE</span>} ${<span style="color: #3498db;">XDISPLAY</span>} -ac &amp;
<span style="color: #3498db;">XEPHYR_PID</span>=$<span style="color: #3498db;">!</span>
sleep 0.5
<span style="color: #2c3e50;">source</span> ~/workspace/virtualenv/qtile-devel/bin/activate
env <span style="color: #3498db;">DISPLAY</span>=${<span style="color: #3498db;">XDISPLAY</span>} ${<span style="color: #3498db;">PYTHON</span>} <span style="color: #16a085;">"${HERE}"</span>/../bin/qtile -l ${<span style="color: #3498db;">LOG_LEVEL</span>} $<span style="color: #3498db;">@</span> &amp;
<span style="color: #3498db;">QTILE_PID</span>=$<span style="color: #3498db;">!</span>

<span style="color: #2c3e50;">export</span> <span style="color: #3498db;">DISPLAY</span>=${<span style="color: #3498db;">XDISPLAY</span>}
<span style="color: #2c3e50;">cd</span> ~/workspace/python/qtile
sleep 0.5
./bin/qtile-cmd -o screen -f info
<span style="color: #3498db;">EXIT_CODE</span>=$<span style="color: #3498db;">?</span>

<span style="color: #2c3e50;">kill</span> -9 $<span style="color: #3498db;">QTILE_PID</span>
<span style="color: #2c3e50;">kill</span> $<span style="color: #3498db;">XEPHYR_PID</span>

<span style="color: #2c3e50; font-style: italic;">exit</span> $<span style="color: #3498db;">EXIT_CODE</span>
</pre>
</div>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-git.html">Git</a> <a href="tag-troubleshooting.html">troubleshooting</a> </div><div id="archive">
<a href="archive.html">Other posts</a>
</div>
</div>
</body>
</html>

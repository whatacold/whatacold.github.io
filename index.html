<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://whatacold.github.io/rss.xml"
      title="RSS feed for https://whatacold.github.io/"/>
<title>whatacold's blog site</title>
<meta name="author" content="Guangwang Huang">
<meta name="referrer" content="no-referrer">
<link href= "static/style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="header">
<div class="sitelinks">
    <a href="https://github.com/whatacold">GitHub</a> | <a href="https://stackoverflow.com/users/910978/whatacold">Stack Overflow</a> | <a href="mailto:whatacold@gmail.com">Email</a> | <a href="/rss.xml">RSS</a>
</div></div>
<div id="content">

<div class="post-date">01 Dec 2019</div><h1 class="post-title"><a href="2019-12-01-why-can't-git-fetch-remote-branches-other-than-master.html">Why can't Git fetch remote branches other than master?</a></h1>
<p>
Last week I came into a problem with Git, that I can't fetch the remote branch that I pushed to. It was so weird because I can push the local branch there. It never happens before, and it happened when I was in a rush to rebase my code, as someone in my team pushed his code.
</p>

<p>
After searching, it seemed that the configuration of <code>fetch</code> of that repo was different(this <a href="https://stackoverflow.com/questions/11623862/fetch-in-git-doesnt-get-all-branches">Stack Overflow</a> thread for example) than before, it was specified that only <code>master</code> can be fetched. It worked after I changed it to <code>+refs/heads/*:refs/remotes/origin/*</code>.
</p>

<p>
I reflected why it happened after work, the only difference I can remember was that I clone that repo with the option <code>--depth &lt;N&gt;</code>, that is, it was a shallow clone to save disk space.
</p>

<p>
Today I had some time at hand, and I confirmed that the option is the problem by reading the git-clone(1) manpage, it notes that:
</p>
<pre class="example">
--depth &lt;depth&gt;
    Create a shallow clone with a history truncated to the specified number of commits. Implies --single-branch unless
    --no-single-branch is given to fetch the histories near the tips of all branches.
</pre>

<p>
Let's demonstrate it by cloning my dotfiles repo with different options, and it shows clearly that Git will only fetch <code>master</code> of the remote repo if only specifying <code>--depth</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ cd /tmp/
$ git clone --depth 1 https://github.com/whatacold/dotfiles.git dotfiles-depth1
$ git clone --no-single-branch --depth 1 https://github.com/whatacold/dotfiles.git dotfiles-no-single-branch
$ git clone https://github.com/whatacold/dotfiles.git dotfiles-full

$ grep <span style="color: #16a085;">'remote "origin"'</span> -A 2 dotfiles-depth1/.git/config 
[remote <span style="color: #16a085;">"origin"</span>]
    <span style="color: #3498db;">url</span> = https://github.com/whatacold/dotfiles.git
    <span style="color: #3498db;">fetch</span> = +refs/heads/master:refs/remotes/origin/master

$ grep <span style="color: #16a085;">'remote "origin"'</span> -A 2 dotfiles-no-single-branch/.git/config 
[remote <span style="color: #16a085;">"origin"</span>]
    <span style="color: #3498db;">url</span> = https://github.com/whatacold/dotfiles.git
    <span style="color: #3498db;">fetch</span> = +refs/heads/*:refs/remotes/origin/*

$ grep <span style="color: #16a085;">'remote "origin"'</span> -A 2 dotfiles-full/.git/config
[remote <span style="color: #16a085;">"origin"</span>]
    <span style="color: #3498db;">url</span> = https://github.com/whatacold/dotfiles.git
    <span style="color: #3498db;">fetch</span> = +refs/heads/*:refs/remotes/origin/*
</pre>
</div>

<p>
I don't know why <code>--single-branch</code> should be implied by default, at least for me, I just want to fetch all the remote branches.
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-git.html">Git</a> </div>
<div class="post-date">25 Nov 2019</div><h1 class="post-title"><a href="2019-11-25-start-a-new-terminal(urxvt)-at-current-buffer's-default-directory-on-emacs.html">Start a new terminal(urxvt) at current buffer's default-directory on Emacs</a></h1>
<p>
I have been really enjoying the more concentration workflow qtile, a tiling window manager, brings me, since I started using it a few months ago. I am more focus on the current task now as all the windows I care about are laid out on the same screen.
</p>

<p>
As I get more used to qtile at every day's work, I noticed that I became more depend on short-life terminal sessions. Sometimes I need to quickly execute some commands on the current buffer on Emacs, such as searching text which having many matches and quit that terminal after I'm done. So I wondered what could be the best way to achieve that.
</p>

<p>
At first, I think maybe I can bind some keys to qtile, which triggers a handler in Python to get the current directory of the current window, and then open a new terminal based on that directory. The problem is how to get the current directory of any window, so I suspend as there isn't a good way to do that.
</p>

<p>
A few days later, I realized that I can just open a terminal from inside Emacs, where it's easy to get the current working directory with <code>default-directory</code>. (The idea was inspired by @ztlevi on Emacs China.) And then I found that I don't really have to open a terminal from any windows, but just from Emacs.
</p>

<p>
With that idea, it didn't take much time to write a command to do that, which I name as <code>urxvt</code>:
</p>
<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">urxvt</span> ()
  <span style="color: #16a085;">"Spawn a urxvt instance based on `</span><span style="color: #7f8c8d; font-style: italic;">default-directory</span><span style="color: #16a085;">' of current buffer."</span>
  (<span style="color: #2c3e50; font-style: italic;">interactive</span>)
  (<span style="color: #2c3e50; font-style: italic;">let</span> ((urxvt <span style="color: #16a085;">"urxvt256c-ml"</span>))
    (start-process urxvt nil urxvt <span style="color: #16a085;">"-cd"</span> (expand-file-name <span style="color: #16a085;">"./"</span>))))
</pre>
</div>

<p>
Sometimes it's important to first clear your mind to figure out what exactly you want.
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-tiling-wm.html">tiling-wm</a> <a href="tag-urxvt.html">urxvt</a> </div>
<div class="post-date">07 Oct 2019</div><h1 class="post-title"><a href="2019-10-07-build-docker-images-for-qtile.html">Build Docker Images for Qtile</a></h1>
<p>
One of Docker's use cases is to set up identical development environments easily and quickly for a dev team.
Recently, I had an opportunity to give it a try, and build Docker images for <a href="https://github.com/qtile/qtile">Qtile</a>, as it didn't have one yet as I get involved. With the images, it's easy to set up the environment to easily run the tests, and build the documentation.
</p>

<p>
The best way to have a basic idea of Docker is to think it like a chroot environment, as Chris Tankersley stated in his <a href="https://leanpub.com/dockerfordevs">Docker for Developers</a>.
And two basic concepts of Docker are image and container, containers to images are what objects to classes as in OOP terminology.
</p>

<p>
The instructions for building a Docker image are put in a <code>Dockerfile</code>, every command builds a new layer on top of the previous one so that I can build my image "on the shoulders of giants".
</p>

<p>
The final Dockerfiles for testing Qtile and building its documentation are hosted at <a href="https://github.com/whatacold/qtile-docker">https://github.com/whatacold/qtile-docker</a>, there is a brief README there about how to build them and use them.</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-docker.html">Docker</a> </div>
<div class="post-date">01 Oct 2019</div><h1 class="post-title"><a href="2019-10-01-reboot-tianyi-router-using-python-requests.html">用 Python Requests “一键”重启天翼路由器</a></h1>
<p>
不知道什么原因，我的网络有时候会很慢，而通过重启天翼网关路由器（版本 V1.0 ）大概率能够恢复。这样重启的次数多了之后会觉得有点繁琐，本着偷懒的原则，就想写一个脚本来自动重启，那样的话会“方便”很多。
</p>

<p>
经过一番折腾，查看其控制台的网页代码，最后终于搞定。通过使用 <a href="https://requests.kennethreitz.org/en/master/">Python Requests</a> 库串联登录及重启两个步骤，达到“一键”自动重启路由器的目的。 Python 脚本如下：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #95a5a6; font-style: italic;">#</span><span style="color: #95a5a6; font-style: italic;">!/usr/bin/env python3</span>
<span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">-*- coding: utf-8 -*-</span>

<span style="color: #2c3e50; font-style: italic;">import</span> requests
<span style="color: #2c3e50; font-style: italic;">import</span> re

<span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">&#36825;&#37324;&#30340;&#37197;&#32622;&#65292;&#35831;&#25353;&#38656;&#20462;&#25913;&#12290;</span>
<span style="color: #3498db;">DEVICE_IP</span>=<span style="color: #16a085;">"192.168.1.1"</span>
<span style="color: #3498db;">USERNAME</span>=<span style="color: #16a085;">'admin'</span>
<span style="color: #3498db;">PASSWORD</span>=<span style="color: #16a085;">'foobar'</span>

<span style="color: #2c3e50; font-style: italic;">def</span> <span style="color: #9b59b6;">reboot</span>():
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #16a085;">'''Reboot the Tianyi Gateway automatically'''</span>
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">s</span> = requests.Session()
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">login_data</span> = <span style="color: #16a085;">"username={}&amp;password={}"</span>.<span style="color: #2c3e50;">format</span>(USERNAME, PASSWORD)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">response</span> = s.post(<span style="color: #16a085;">"http://{}/login.cgi"</span>.<span style="color: #2c3e50;">format</span>(DEVICE_IP), login_data)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">response_html</span> = response.text
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">matches</span> = re.findall(<span style="color: #16a085;">'var mysessionid=([0-9]+);'</span>, response_html)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">if</span> 1 != <span style="color: #2c3e50;">len</span>(matches):
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">raise</span> <span style="color: #16a085;">"No session id matched!"</span>

<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">session_id</span> = matches[0]
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">session_id = 1111 # It doesn't care what it REALLY is</span>
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">response</span> = s.post(<span style="color: #16a085;">"http://{}/restartGateWay.json?sessionKey={}"</span>.<span style="color: #2c3e50;">format</span>(DEVICE_IP,
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>  session_id),
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span> <span style="color: #16a085;">"action=restartGateWay&amp;actionid=8"</span>)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">text</span> = response.text <span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">{ "status": "success", "actionid": "8" }</span>
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #3498db;">return_object</span> = response.json()
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">if</span> <span style="color: #16a085;">"success"</span> == return_object[<span style="color: #16a085;">"status"</span>]:
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">print</span>(<span style="color: #16a085;">"Device rebooted successfully, wait a minute!"</span>)
<span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">else</span>:
<span style="background-color: #ecf0f1;"> </span>   <span style="background-color: #ecf0f1;"> </span>   <span style="color: #2c3e50; font-style: italic;">print</span>(<span style="color: #16a085;">"Failed to reboot the device, return json: {}"</span>.<span style="color: #2c3e50;">format</span>(text))

<span style="color: #2c3e50; font-style: italic;">if</span> <span style="color: #2c3e50;">__name__</span> == <span style="color: #16a085;">'__main__'</span>:
<span style="background-color: #ecf0f1;"> </span>   reboot()
</pre>
</div>

<p>
此脚本依赖 Python Requests 库，可以通过 <code>pip</code> 来安装；我使用 Python3 ，不过 Python2 应该也不会有太大问题。
把上述脚本保存到文件中，比如 <code>~/bin/reboot-tianyi-gateway</code> ，并且增加可执行权限（ <code>chmod +x ~/bin/reboot-tianyi-gateway</code> ），在需要的时候在终端中执行 <code>~/bin/reboot-tianyi-gateway</code> 即可。 :)
</p>

<p>
另外，正如注释中提到的，其实 <code>/restartGateWay.json</code> 这个是一个裸接口，并没有校验 <code>sessionKey</code> 的有效性；甚至登录接口在用户登录之后也不会设置 cookie ，所有的业务接口都是可以直接调用的，也就是说，登录界面只是一个摆设。 :(
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-python.html">Python</a> </div>
<div class="post-date">29 Sep 2019</div><h1 class="post-title"><a href="2019-09-29-how-to-run-the-bleeding-edge-code-of-qtile-within-virtualenv.html">How to run the bleeding-edge code of Qtile within a virtualenv</a></h1>
<p>
For having been using GNOME for quite a long time, I was considering trying some tiling window managers to see what it's like a few weeks ago. Along the way, I found a nice window manager written in Python: <a href="http://www.qtile.org">Qtile</a>, what interests me most is that it's a <b>hackable</b> window manager, which makes it flexible to extend or change its behaviors.
</p>

<p>
Well, switching to use a tiling window manager is far simpler than I thought. There are two ways to have it:
</p>
<ol class="org-ol">
<li>Installing it via the system's package manager, e.g. <code>dnf</code> for Fedora</li>
<li>Installing it from the source code repo.</li>
</ol>

<p>
If you just want to give it a try, you can just install it via a package manager, logout the current X session, and re-login with Qtile as your window manager (there are options when you log in), and you're done. It's that simple.
</p>

<p>
As Qtile is still under development, I would like to run the bleeding-edge source code to catch up with Qtile.
</p>

<p>
As in the <a href="http://docs.qtile.org/en/latest/manual/install/index.html#qtile">docs</a> , it's quite straight-forward to install it.
</p>

<div class="org-src-container">
<pre class="src src-shell">git clone git://github.com/qtile/qtile.git
<span style="color: #2c3e50;">cd</span> qtile
pip3 install .
</pre>
</div>

<p>
But it will pollute the environment, so I'd rather contain it within a virtualenv, here are the steps how to run it within a dedicated virtualenv for user <code>foo</code> on Fedora.
</p>

<ol class="org-ol">
<li><p>
Clone the repo
</p>

<div class="org-src-container">
<pre class="src src-shell">mkdir -p ~/local/
git clone https://github.com/qtile/qtile.git
</pre>
</div></li>

<li><p>
Create a new virtualenv, and install dependencies there
</p>

<div class="org-src-container">
<pre class="src src-shell">python3 -m venv ~/local/qtile/qtile-env/
<span style="color: #2c3e50;">source</span> ~/local/qtile/qtile-env/bin/activate

<span style="color: #95a5a6; font-style: italic;"># </span><span style="color: #95a5a6; font-style: italic;">Install dependencies</span>
pip install xcffib
pip install --no-cache-dir cairocffi
</pre>
</div></li>

<li><p>
Make a glue shell script to use the virtualenv
</p>

<div class="org-src-container">
<pre class="src src-shell">cat &gt; /home/foo/local/qtile/qtile-venv-entry &lt;&lt;EOF
<span style="color: #16a085;">#!/bin/bash</span>

<span style="color: #16a085;"># This glue shell is only needed when you want to</span>
<span style="color: #16a085;"># run Qtile within a virtualenv</span>

<span style="color: #16a085;">source ~/local/qtile/qtile-env/bin/activate</span>
<span style="color: #16a085;">python ~/local/qtile/bin/qtile $*</span>
<span style="color: #16a085;">EOF</span>
</pre>
</div>

<p>
Also, make sure to make it executable, that is, <code>chmod +x /home/foo/local/qtile/qtile-venv-entry</code>
</p></li>

<li><p>
Make a entry desktop file for the display manager
</p>

<div class="org-src-container">
<pre class="src src-shell">cat &gt; /usr/share/xsessions/qtile-venv.desktop &lt;&lt;EOF
<span style="color: #16a085;">[Desktop Entry]</span>
<span style="color: #16a085;">Name=Qtile(venv)</span>
<span style="color: #16a085;">Comment=Qtile Session Within Venv</span>
<span style="color: #16a085;">Exec=/home/foo/local/qtile/qtile-venv-entry</span>
<span style="color: #16a085;">Type=Application</span>
<span style="color: #16a085;">Keywords=wm;tiling</span>
<span style="color: #16a085;">EOF</span>
</pre>
</div>

<p>
Pay attention to the <code>Exec</code> directive, it points to the glue script.
</p></li>

<li>Log out or reboot your system, then select “Qtile(venv)” as your window manager by clicking the setting icon when logging in.</li>
</ol>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-python.html">Python</a> <a href="tag-tiling-wm.html">tiling-wm</a> </div><div id="archive">
<a href="archive.html">Other posts</a>
</div>
</div>
</body>
</html>

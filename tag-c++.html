<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://whatacold.github.io/rss.xml"
      title="RSS feed for https://whatacold.github.io/">
<title>whatacold's blog site</title>
<meta name="author" content="Guangwang Huang">
<meta name="referrer" content="no-referrer">
<link href= "static/style.css" rel="stylesheet" type="text/css" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-74588785-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-74588785-1');
</script>
</head>
<body>
<div id="preamble" class="status"><div class="header">
<div class="sitelinks">
    <a href="https://github.com/whatacold">GitHub</a> | <a href="https://stackoverflow.com/users/910978/whatacold">Stack Overflow</a> | <a href="mailto:whatacold@gmail.com">Email</a> | <a href="/rss.xml">RSS</a>
</div></div>
<div id="content">
<h1 class="title">Posts tagged "C++":</h1>
<div class="post-date">16 Feb 2021</div><h1 class="post-title"><a href="https://whatacold.github.io/zh/2021-02-16-doxygen-cpp-correct-callgraphs.html">Doxygen 终于可以正确生成函数调用图了！</a></h1>
<p>
大家都知道， Doxygen 可以用于提取代码的注释生成项目的文档，只要注释满足其规定的格式。但我更喜欢利用它生成类继承图（inheritance diagram）和函数调用图（callgraph），通过他们能够加快对代码的理解。
</p>

<p>
以 MySQL 代码为例， Doxygen 生成的类继承图和调用图分别是这样的：
</p>

<figure>
<img src="./images/2021-02-16-doxygen_innodb_classhandler__inherit__graph.png" alt="2021-02-16-doxygen_innodb_classhandler__inherit__graph.png">

<figcaption><span class="figure-number">Figure 1: </span>handler （存储引擎）类继承图</figcaption>
</figure>


<figure>
<img src="./images/2021-02-16-doxygen_mysql_ha_recover_callgraph.png" alt="2021-02-16-doxygen_mysql_ha_recover_callgraph.png" width="1000">

<figcaption><span class="figure-number">Figure 2: </span>ha_recover() crash recovery 函数调用图</figcaption>
</figure>

<p>
之前工作中交接了几个 C++ 项目，由于还不熟悉，就想用 Doxygen 来生成这两种图来加快熟悉代码，但结果却生成失败了。
</p>

<p>
几经排查，最后发现只要代码中包含2个以上的 <code>using namespace xxx;</code> 语句，调用图就无法生成。比如下面这样一个简单的类实现，就无法生成调用关系图。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>test.h 代码</label><pre class="src src-c++"><span style="color: #2c3e50;">#pragma</span> once

<span style="color: #2c3e50; font-style: italic;">namespace</span> <span style="color: #7f8c8d; font-style: italic;">demo</span> {
    <span style="color: #2c3e50; font-style: italic;">class</span> <span style="color: #27ae60;">Test</span> {
    <span style="color: #2c3e50; font-style: italic;">public</span>:
        <span style="color: #27ae60;">void</span> <span style="color: #9b59b6;">foo</span>();
        <span style="color: #27ae60;">void</span> <span style="color: #9b59b6;">bar</span>();
    };
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>test.cpp 代码</label><pre class="src src-c++"><span style="color: #2c3e50;">#include</span> <span style="color: #16a085;">&lt;iostream&gt;</span>
<span style="color: #2c3e50;">#include</span> <span style="color: #16a085;">"test.h"</span>

<span style="color: #2c3e50; font-style: italic;">using</span> <span style="color: #2c3e50; font-style: italic;">namespace</span> <span style="color: #7f8c8d; font-style: italic;">demo</span>;
<span style="color: #2c3e50; font-style: italic;">using</span> <span style="color: #2c3e50; font-style: italic;">namespace</span> <span style="color: #7f8c8d; font-style: italic;">std</span>;

<span style="color: #27ae60;">void</span> <span style="color: #7f8c8d; font-style: italic;">Test</span>::<span style="color: #9b59b6;">foo</span>()
{
    bar();
}

<span style="color: #27ae60;">void</span> <span style="color: #7f8c8d; font-style: italic;">Test</span>::<span style="color: #9b59b6;">bar</span>()
{
    <span style="color: #2c3e50; font-style: italic;">return</span>;
}

<span style="color: #27ae60;">int</span> <span style="color: #9b59b6;">main</span>()
{
    <span style="color: #27ae60;">Test</span> <span style="color: #3498db;">test</span>;
    test.foo();
    <span style="color: #2c3e50; font-style: italic;">return</span> 0;
}
</pre>
</div>

<p>
虽然这种直接包含命名空间的用法不推荐，但是在已有项目中却很常见，这就意味着 Doxygen 基本不可用了。
</p>

<p>
由于当时没有时间，就先给官方报了一个 <a href="https://github.com/doxygen/doxygen/issues/8011">Issue</a> ，等待他们解决。
</p>

<p>
没想到几个月之后，官方也还没有解决，而最近正好有点时间，就重新去分析这个 bug ，看如何解决。解决过程虽然花了不少时间，但总结起来就几点：
</p>
<ol class="org-ol">
<li>对比正常生成调用图和无法生成调用图的两种输出，再 grep 差异信息定位到生成 callgraph 图的相关代码；</li>
<li>添加 printf 调试信息，找出 callgraph 元数据的来源，即 Doxygen 怎么得到调用关系的，最终找到实现在 <code>code.l</code> （C族语言的 flex 实现，用于解析工程源码）中，其中基于 flex 自己实现了词法解析；</li>
<li>学习 flex 的使用方法；</li>
</ol>

<p>
最后终于找到问题的根源在于， Doxygen 在解析 <code>using namespace xxx;</code> 指令的时候，错误地把文件中其后的代码包围在 xxx 命名空间中（ <code>pushScope</code> ），从而把函数的绝对命名空间弄错，就没法解析出正确的调用关系了。
</p>

<p>
提了 <a href="https://github.com/doxygen/doxygen/pull/8376">PR</a> 修复了之后， Doxygen 就能够正常地生成调用图了，前面的测试代码就能正确地生成如下的函数调用图了。
</p>


<figure>
<img src="./images/2021-02-16-doxygen_fix_test_callgraph.png" alt="2021-02-16-doxygen_fix_test_callgraph.png">

<figcaption><span class="figure-number">Figure 3: </span>Test::foo() 的调用图</figcaption>
</figure>

<p>
目前（2021.02）这个 PR 已经合并到 master 了，但是还没有发布，需要再等一等。
</p>
<div class="taglist"><a href="https://whatacold.github.io/tags.html">Tags</a>: <a href="https://whatacold.github.io/tag-c++.html">C++</a> </div>
<div class="post-date">22 Dec 2018</div><h1 class="post-title"><a href="https://whatacold.github.io/zh/2018-12-22-c-cpp-devel-with-lsp-in-emacs.html">在 Emacs 中使用 LSP 开发 C/C++ 工程</a></h1>
<p>
写代码的时候，如果能够基于当前的上下文提示补全，不仅能提高写代码的效率，还能提升体验，有种行云流水的感觉。
Emacs 中之前我用 gtags 等静态的工具来辅助写代码，最大的问题是无法根据上下文补全，体验不好。
有了 LSP 协议之后， Emacs 中现在也能实现这个功能了，体验相当不错。
前段时间折腾了一下，在此作个小结。
</p>

<p>
目前 Emacs 上有两个客户端实现： <a href="https://github.com/joaotavora/eglot">eglot</a> 和 <a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> ，由于 eglot 相对比较简洁，只需要很少的配置，因此我就选它了（暂时还没试过 lsp-mode ，等有需要时再看）。
</p>

<p>
对于服务端，目前有三个选择 clangd,  <a href="https://github.com/cquery-project/cquery">cquery</a> 和 <a href="https://github.com/MaskRay/ccls">ccls</a> ， ccls 是在 cquery 的基础之上 fork 改进的。
clangd 安装最简单，但功能据说比较弱，我没有试过；一开始我在自己电脑上编译了 ccls ，再把二进制文件拷贝到公司机器，
但是补全始终有问题（怀疑必须在使用的机器上编译，直接拷贝行不通），没有找到具体的原因；
后来在公司机器上直接编译了 cquery ，可以补全，就没有再折腾 ccls 了。
</p>

<p>
选定了客户端和服务端之后，接下来就是对具体工程的配置了， cquery 和 ccls 都要求工程根目录有 compilation database 或者 <code>.cquery</code> / <code>.ccls</code> 文件。
由于我们的工程都是用 GNU Make 进行构建的，没法使用 <code>cmake</code> 直接生成 compilation database 。
其他方案比如 <a href="https://github.com/rizsotto/Bear">Bear</a> ，由于我们的工具链太老，没有 <code>cmake</code> 无法编译 <code>Bear</code> ，因此也派不上用场。
至此由于无法生成服务器的配置文件，看来似乎与 LSP 无缘了。
</p>

<p>
后来有一天，突然想到可以直接自己解析 <code>make</code> 的输出（就用 Elisp ），解析 <code>Entering directory</code> , <code>Leaving directory</code> 以及 <code>g++</code> 编译的相关行，
提取生成为 <code>compile_commands.json</code> ，这样就无须再依赖其他软件。
但是此方法有一个缺点，在新增文件的时候，得人工在 json 文件中增加一条记录，比较麻烦，不易维护。
</p>

<p>
其实此种情况下直接用 <code>.cquery</code> 文件最好，无需指定特定的源码文件，
只需要配置编译选项以及头文件目录，因此新增文件时不需要修改。
举一个 cquery wiki 中的 <a href="https://github.com/cquery-project/cquery/wiki/.cquery">例子</a> ：
</p>

<pre class="example">
# it will expend to clang/clang++ according to the extension name
%clang

# C specific options
%c -std=gnu11

# C++ specific options
%cpp -std=gnu++14
-pthread

# Includes
-I/work/cquery/third_party
-I/work/cquery/another_third_party
# -I space_is_not_allowed
</pre>


<p>
到此似乎万事俱备，可以愉快地写代码了，最终却发现还有一个问题：由于历史原因，我们的工程源码都是使用 GBK 编码的，
但是 LSP 只支持 UTF-8 ，导致由于编码问题无法显示类、函数注释的问题，当时还在 eglot 提了一个 <a href="https://github.com/joaotavora/eglot/issues/135">issue</a> （其实不是 eglot 的问题）。
</p>

<p>
为了解决这个问题想过几种方法：
</p>
<ol class="org-ol">
<li>cquery 中在输出之前，把内容转为 UTF-8 编码（利用 <code>iconv</code> 库）</li>
<li><code>eglot</code> 在解析服务端返回的数据时，根据指定的编码进行 decode</li>
</ol>

<p>
第一种方法适用面太窄，因为 LSP 的实现还不是非常成熟，有时需要切换到 <code>ccls</code> 来体验，
这就意味着得在 <code>ccls</code> 中也用 <code>iconv</code> 再转一道，太麻烦，不符合 <code>DRY</code> 的原则。
</p>

<p>
第二种方法，需要在 <code>eglot.el</code> 和其依赖的低层通信库 <code>jsonrpc.el</code> 中同时服务端传回数据的编码方式。
当时也实现了，后来觉得不是很直接、优雅，就没再继续用了。另外，如果有一天改用 lsp-mode ，
那又需要在 lsp-mode 中做一遍类似的修改，同样也不符合 <code>DRY</code> 原则。
</p>

<p>
最后使用了适配器的 <a href="https://github.com/whatacold/lsa">方案</a> ，使用 Python 3 实现，既不动客户端也不动服务端，在中间加一层，用于转换服务端的编码。
这样就是一个比较通用的方案了，能适配所有的客户端和服务端。
</p>

<p>
在 eglot 中根据项目的编码情况（通过 <code>.dir-locals.el</code> 区分）决定是否使用此适配器：
</p>

<div class="org-src-container">
<pre class="src src-elisp">
(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">ccls-init-args</span> nil
  <span style="color: #16a085;">"Init args for ccls, e.g. '(:clang (:extraArgs (\"-std=c++03\")))"</span>)

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">eglot-ls-output-encoding</span> <span style="color: #16a085;">"utf-8"</span>
  <span style="color: #16a085;">"The LS's output encoding"</span>)

(<span style="color: #2c3e50; font-style: italic;">defcustom</span> <span style="color: #3498db;">eglot-cpp-ls</span> <span style="color: #16a085;">"cquery"</span>
  <span style="color: #16a085;">"The language server for C/C++."</span>)

(<span style="color: #2c3e50; font-style: italic;">defun</span> <span style="color: #9b59b6;">whatacold/eglot-ccls-contact</span> (interactive-p)
  <span style="color: #16a085;">"A contact function to assemble args for ccls.</span>
<span style="color: #16a085;">Argument INTERACTIVE-P indicates where it's called interactively."</span>
  (<span style="color: #2c3e50; font-style: italic;">let</span> ((json-object-type 'plist)
        (json-array-type 'list)
        result)
    (<span style="color: #2c3e50; font-style: italic;">cond</span> ((equal <span style="color: #16a085;">"ccls"</span> eglot-cpp-ls)
           (<span style="color: #2c3e50; font-style: italic;">push</span> (format <span style="color: #16a085;">"-log-file=/tmp/ccls-%s.log"</span>
                         (file-name-base
                          (directory-file-name
                           (car
                            (project-roots
                             (project-current))))))
                 result)
           (<span style="color: #2c3e50; font-style: italic;">when</span> ccls-init-args
             (<span style="color: #2c3e50; font-style: italic;">push</span> (format <span style="color: #16a085;">"-init=%s"</span> (json-encode
                                       ccls-init-args))
                   result))
           (<span style="color: #2c3e50; font-style: italic;">push</span> <span style="color: #16a085;">"ccls"</span> result))
          ((equal <span style="color: #16a085;">"cquery"</span> eglot-cpp-ls)
           (<span style="color: #2c3e50; font-style: italic;">setq</span> result (list <span style="color: #16a085;">"cquery"</span> <span style="color: #16a085;">"--log-all-to-stderr"</span>)))
          (t <span style="color: #95a5a6; font-style: italic;">; </span><span style="color: #95a5a6; font-style: italic;">e.g. clangd</span>
           (<span style="color: #2c3e50; font-style: italic;">push</span> eglot-cpp-ls result)))
    <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">apply the adapter if necessary</span>
    (<span style="color: #2c3e50; font-style: italic;">unless</span> (equal eglot-ls-output-encoding <span style="color: #16a085;">"utf-8"</span>)
      (<span style="color: #2c3e50; font-style: italic;">dolist</span> (item (reverse (list <span style="color: #16a085;">"lsa.py"</span>
                                   (concat <span style="color: #16a085;">"--original-response-encoding="</span>
                                           eglot-ls-output-encoding)
                                   <span style="color: #16a085;">"--log-level=DEBUG"</span>
                                   <span style="color: #16a085;">"--"</span>)))
        (<span style="color: #2c3e50; font-style: italic;">push</span> item result)))
    <span style="color: #95a5a6; font-style: italic;">;; </span><span style="color: #95a5a6; font-style: italic;">cquery should apply the specific class in eglot</span>
    (<span style="color: #2c3e50; font-style: italic;">when</span> (equal <span style="color: #16a085;">"cquery"</span> eglot-cpp-ls)
      (<span style="color: #2c3e50; font-style: italic;">push</span> 'eglot-cquery result))
    result))

(eval-after-load 'eglot
  '(<span style="color: #2c3e50; font-style: italic;">progn</span>
     (add-to-list 'eglot-server-programs
                  (cons '(c-mode c++-mode foo-mode) #'whatacold/eglot-ccls-contact))))
</pre>
</div>

<p>
至此 LSP 基本可用了。</p>
<div class="taglist"><a href="https://whatacold.github.io/tags.html">Tags</a>: <a href="https://whatacold.github.io/tag-emacs.html">Emacs</a> <a href="https://whatacold.github.io/tag-c++.html">C++</a> <a href="https://whatacold.github.io/tag-python.html">Python</a> </div>
<div class="post-date">10 Dec 2018</div><h1 class="post-title"><a href="https://whatacold.github.io/zh/2018-12-10-how-polymorphism-works-in-cpp.html">C++ 多态是如何实现的？</a></h1>
<p>
对于 OOP 编程，相信大家对于多态（ polymorphism ）肯定都耳熟能详。
但是对于多态是如何实现的，我不知道大家是否清楚，但我发现自己并不是很了解，
只知道在运行时通过一个 vtable 来确定应该调用哪个函数，
实际上 vtable 真的存在吗？它是如何起作用的？
</p>

<p>
首先我们来看下普通方法的调用情况，比如 <code>non-virtual-class.cpp</code> 有一个类及其方法调用：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #2c3e50; font-style: italic;">class</span> <span style="color: #27ae60;">Base</span>
{
<span style="color: #2c3e50; font-style: italic;">public</span>:
    <span style="color: #27ae60;">int</span> <span style="color: #9b59b6;">foo</span>() { <span style="color: #2c3e50; font-style: italic;">return</span> 1; }
};

<span style="color: #2c3e50; font-style: italic;">class</span> <span style="color: #27ae60;">Derived</span>
{
<span style="color: #2c3e50; font-style: italic;">public</span>:
    <span style="color: #27ae60;">int</span> <span style="color: #9b59b6;">bar</span>() { <span style="color: #2c3e50; font-style: italic;">return</span> 2; }
};

<span style="color: #27ae60;">int</span> <span style="color: #9b59b6;">main</span>(<span style="color: #27ae60;">void</span>)
{
    <span style="color: #27ae60;">Derived</span> <span style="color: #3498db;">foo</span>;

    <span style="color: #2c3e50; font-style: italic;">return</span> foo.bar();
}
</pre>
</div>

<p>
<code>g++ -g -O0 non-virtual-class.cpp</code> 编译之后，用 <code>gdb a.out</code> 查看它的汇编代码：
</p>

<pre class="example">
(gdb) disas main
Dump of assembler code for function main():
   0x00000000004004b6 &lt;+0&gt;:	push   %rbp
   0x00000000004004b7 &lt;+1&gt;:	mov    %rsp,%rbp
   0x00000000004004ba &lt;+4&gt;:	sub    $0x10,%rsp
   0x00000000004004be &lt;+8&gt;:	lea    -0x1(%rbp),%rax               ; &amp;foo 取自身对象地址
   0x00000000004004c2 &lt;+12&gt;:	mov    %rax,%rdi
   0x00000000004004c5 &lt;+15&gt;:	callq  0x4004ce &lt;Derived::bar()&gt; ; 确定的函数地址
   0x00000000004004ca &lt;+20&gt;:	nop
   0x00000000004004cb &lt;+21&gt;:	leaveq 
   0x00000000004004cc &lt;+22&gt;:	retq   
End of assembler dump.
(gdb) disas Derived::bar
Dump of assembler code for function Derived::bar():
   0x00000000004004ce &lt;+0&gt;:	push   %rbp
   0x00000000004004cf &lt;+1&gt;:	mov    %rsp,%rbp
   0x00000000004004d2 &lt;+4&gt;:	mov    %rdi,-0x8(%rbp)
   0x00000000004004d6 &lt;+8&gt;:	mov    $0x2,%eax                     ; return 2
   0x00000000004004db &lt;+13&gt;:	pop    %rbp
   0x00000000004004dc &lt;+14&gt;:	retq   
End of assembler dump.
</pre>

<p>
可以发现与普通的 C 函数调用类似，编译之后就已经确定好了调用 <code>Derived::bar</code> 方法，
除了把对象自身地址作为隐藏的第一个参数传入之外并没有什么不同。
也就是说对于普通不含虚函数的类对象，在编译过程中就确定了其方法的调用，没有运行时开销。
</p>

<p>
那么，在多态场景下，类方法的调用又是怎样的呢？这里还是从汇编的角度观察。
以同样参数编译如下 <code>virtual-class-polymorphism.cpp</code> 文件，然后用 gdb 观察运行时信息：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #2c3e50; font-style: italic;">class</span> <span style="color: #27ae60;">Base</span>
{
<span style="color: #2c3e50; font-style: italic;">public</span>:
    <span style="color: #2c3e50; font-style: italic;">virtual</span> <span style="color: #27ae60;">void</span> <span style="color: #9b59b6;">foo</span>() {};
};

<span style="color: #2c3e50; font-style: italic;">class</span> <span style="color: #27ae60;">Derived</span> : <span style="color: #2c3e50; font-style: italic;">public</span> <span style="color: #27ae60;">Base</span>
{
<span style="color: #2c3e50; font-style: italic;">public</span>:
    <span style="color: #27ae60;">void</span> <span style="color: #9b59b6;">foo</span>() {};
};

<span style="color: #27ae60;">int</span> <span style="color: #9b59b6;">main</span>(<span style="color: #27ae60;">void</span>)
{
    <span style="color: #27ae60;">Base</span> *<span style="color: #3498db;">p</span> = <span style="color: #2c3e50; font-style: italic;">new</span> <span style="color: #27ae60;">Derived</span>;
    p-&gt;foo();

    <span style="color: #2c3e50; font-style: italic;">return</span> 0;
}
</pre>
</div>

<p>
这次我们通过在 GDB 运行时观察：
</p>
<pre class="example">
;; 设置解析符号及断点，启动程序
(gdb) set print asm-demangle on
(gdb) set print demangle on
(gdb) b main
Breakpoint 1 at 0x40061f: file virtual-class-polymorphism.cpp, line 15.
(gdb) r
Starting program: /home/hgw/demo-code/cpp/vtable/a.out 
Missing separate debuginfos, use: dnf debuginfo-install glibc-2.27-30.fc28.x86_64

Breakpoint 1, main () at virtual-class-polymorphism.cpp:15
15	    Base *p = new Derived;
Missing separate debuginfos, use: dnf debuginfo-install libgcc-8.1.1-5.fc28.x86_64 libstdc++-8.1.1-5.fc28.x86_64
(gdb) p p
$1 = (Base *) 0x400530 &lt;_start&gt;
(gdb) n
16	    p-&gt;foo();

(gdb) p p
$2 = (Base *) 0x613e70
(gdb) x/16xb p
0x613e70:	0x40	0x07	0x40	0x00	0x00	0x00	0x00	0x00
0x613e78:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
;; 可以看到对象中包含了一个 vptr ，指向 vtable 的一个偏移位置
(gdb) p *p
$3 = {_vptr.Base = 0x400740 &lt;vtable for Derived+16&gt;}

;; 再看 vtable 中的内容，注意这里已经去掉了偏移量16
;; 可以看到先是两个 vtable ，再是 typeinfo ， typeinfo name ，后两者是 RTTI 相关，本文暂不了解。
(gdb) x/200xb 0x400730
0x400730 &lt;vtable for Derived&gt;:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x400738 &lt;vtable for Derived+8&gt;:	0x60	0x07	0x40	0x00	0x00	0x00	0x00	0x00
0x400740 &lt;vtable for Derived+16&gt;:	0x64	0x06	0x40	0x00	0x00	0x00	0x00	0x00
0x400748 &lt;vtable for Base&gt;:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x400750 &lt;vtable for Base+8&gt;:	0x88	0x07	0x40	0x00	0x00	0x00	0x00	0x00
0x400758 &lt;vtable for Base+16&gt;:	0x58	0x06	0x40	0x00	0x00	0x00	0x00	0x00
0x400760 &lt;typeinfo for Derived&gt;:	0xa8	0x0d	0x60	0x00	0x00	0x00	0x00	0x00
0x400768 &lt;typeinfo for Derived+8&gt;:	0x78	0x07	0x40	0x00	0x00	0x00	0x00	0x00
0x400770 &lt;typeinfo for Derived+16&gt;:	0x88	0x07	0x40	0x00	0x00	0x00	0x00	0x00
0x400778 &lt;typeinfo name for Derived&gt;:	0x37	0x44	0x65	0x72	0x69	0x76	0x65	0x64
0x400780 &lt;typeinfo name for Derived+8&gt;:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x400788 &lt;typeinfo for Base&gt;:	0x50	0x0d	0x60	0x00	0x00	0x00	0x00	0x00
0x400790 &lt;typeinfo for Base+8&gt;:	0x98	0x07	0x40	0x00	0x00	0x00	0x00	0x00
0x400798 &lt;typeinfo name for Base&gt;:	0x34	0x42	0x61	0x73	0x65	0x00	0x00	0x00
0x4007a0:	0x01	0x1b	0x03	0x3b	0x5c	0x00	0x00	0x00
;; 这里省略一些无意义的输出

;; 查看 &lt;vtable for Derived+16&gt; 地址中存储的内容，可以看到就是函数指针
(gdb) info symbol 0x400664
Derived::foo() in section .text of /home/hgw/demo-code/cpp/vtable/a.out
;; 查看 &lt;vtable for Derived+8&gt; 地址中存储的内容，指向 typeinfo 内存位置
(gdb) info symbol 0x400760
typeinfo for Derived in section .rodata of /home/hgw/demo-code/cpp/vtable/a.out
</pre>

<p>
现在再回过头来看静态的汇编代码，就容易理解了：
</p>
<pre class="example">
(gdb) disas main
Dump of assembler code for function main():
   0x0000000000400616 &lt;+0&gt;:	push   %rbp
   0x0000000000400617 &lt;+1&gt;:	mov    %rsp,%rbp
   0x000000000040061a &lt;+4&gt;:	push   %rbx
   0x000000000040061b &lt;+5&gt;:	sub    $0x18,%rsp
   0x000000000040061f &lt;+9&gt;:	mov    $0x8,%edi                         ; sizeof Derived 变为了 8 字节
   0x0000000000400624 &lt;+14&gt;:	callq  0x400520 &lt;_Znwm@plt&gt;          ; new 对象
   0x0000000000400629 &lt;+19&gt;:	mov    %rax,%rbx                     ; 地址 p
   0x000000000040062c &lt;+22&gt;:	mov    %rbx,%rdi
   0x000000000040062f &lt;+25&gt;:	callq  0x400688 &lt;Derived::Derived()&gt; ; constructor
   0x0000000000400634 &lt;+30&gt;:	mov    %rbx,-0x18(%rbp)
   0x0000000000400638 &lt;+34&gt;:	mov    -0x18(%rbp),%rax              ; 地址 p ，指向对象存储空间
   0x000000000040063c &lt;+38&gt;:	mov    (%rax),%rax                   ; 取对象内容，其实就是 vptr 值
   0x000000000040063f &lt;+41&gt;:	mov    (%rax),%rax                   ; 取 vptr 指向地址的内容，就是上边看到的 &lt;vtable for Derived+16&gt;
   0x0000000000400642 &lt;+44&gt;:	mov    -0x18(%rbp),%rdx
   0x0000000000400646 &lt;+48&gt;:	mov    %rdx,%rdi                     ; 把地址 p 作为第一个参数（ this ）传入
   0x0000000000400649 &lt;+51&gt;:	callq  *%rax                         ; 调用 vtable 中指定的函数
   0x000000000040064b &lt;+53&gt;:	mov    $0x0,%eax
   0x0000000000400650 &lt;+58&gt;:	add    $0x18,%rsp
   0x0000000000400654 &lt;+62&gt;:	pop    %rbx
   0x0000000000400655 &lt;+63&gt;:	pop    %rbp
   0x0000000000400656 &lt;+64&gt;:	retq   
End of assembler dump.
</pre>

<p>
综上，可以把相关的内存布局绘制成如下图：
</p>


<figure>
<img src="./images/2018-12-10-vtable.png" alt="2018-12-10-vtable.png">

</figure>

<p>
从以上分析可以看出， vtable 确实存在，程序运行时根据 vtable 查找对应的函数（此过程叫做 dynamic dispatch ）。
若在不必要的场景下定义了虚函数，一方面会使得对象占用的内存变大，
另一方面在调用虚函数时，需要查找 vtable ，有一定的性能损耗，因此编程时应当避免此情况。
</p>

<p>
延伸阅读、参考资料：
</p>
<ul class="org-ul">
<li><p>
<a href="https://shaharmike.com/cpp/vtable-part1/">C++ vtables - Part 1 - Basics | Shahar Mike's Web Spot - shaharmike.com</a>
</p>

<p>
此系列文章深入讲解了 C++ 的 vtable 和 RTTI 实现原理，本文主要参考了其中的第一篇。
</p></li>
<li><a href="http://lifegoo.pluskid.org/upload/doc/object_models/C++%20Object%20Model.pdf">C++ Object Model.pdf - lifegoo.pluskid.org</a></li>
<li>Stanley B·Lippman <a href="https://book.douban.com/subject/1091086/">Inside the C++ Object Model</a></li>
</ul>
<div class="taglist"><a href="https://whatacold.github.io/tags.html">Tags</a>: <a href="https://whatacold.github.io/tag-c++.html">C++</a> <a href="https://whatacold.github.io/tag-gdb.html">GDB</a> </div><div id="archive">
<a href="https://whatacold.github.io/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"></div>
</body>
</html>
